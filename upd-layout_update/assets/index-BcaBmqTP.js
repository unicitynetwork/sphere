import{v as He,r as Rn,a as ee,c as Mn,b as Z,i as Nn,d as ne,e as Ke,f as $n,h as Ie,j as _e,k as On,w as Fn,n as Yt,l as Vn,m as Be,s as zn,o as nt,p as X,q as jn,t as ue,u as et}from"./index-Cn0ZKJ58.js";class _ extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}}class qe extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}class Ge extends Error{static name="InvalidPrivateKeyError";constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}}class vo extends Error{static name="InvalidCIDError";constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}class Ko extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}class _t extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}function Hn(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function zt(e){if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}function qn(e){return new TextEncoder().encode(e)}function Gn(e){return new TextDecoder().decode(e)}function Zn(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var s=0;s<e.length;s++){var i=e.charAt(s),o=i.charCodeAt(0);if(n[o]!==255)throw new TypeError(i+" is ambiguous");n[o]=s}var c=e.length,a=e.charAt(0),m=Math.log(c)/Math.log(256),w=Math.log(256)/Math.log(c);function b(d){if(d instanceof Uint8Array||(ArrayBuffer.isView(d)?d=new Uint8Array(d.buffer,d.byteOffset,d.byteLength):Array.isArray(d)&&(d=Uint8Array.from(d))),!(d instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(d.length===0)return"";for(var K=0,x=0,u=0,l=d.length;u!==l&&d[u]===0;)u++,K++;for(var f=(l-u)*w+1>>>0,p=new Uint8Array(f);u!==l;){for(var A=d[u],I=0,S=f-1;(A!==0||I<x)&&S!==-1;S--,I++)A+=256*p[S]>>>0,p[S]=A%c>>>0,A=A/c>>>0;if(A!==0)throw new Error("Non-zero carry");x=I,u++}for(var h=f-x;h!==f&&p[h]===0;)h++;for(var y=a.repeat(K);h<f;++h)y+=e.charAt(p[h]);return y}function v(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return new Uint8Array;var K=0;if(d[K]!==" "){for(var x=0,u=0;d[K]===a;)x++,K++;for(var l=(d.length-K)*m+1>>>0,f=new Uint8Array(l);d[K];){var p=n[d.charCodeAt(K)];if(p===255)return;for(var A=0,I=l-1;(p!==0||A<u)&&I!==-1;I--,A++)p+=c*f[I]>>>0,f[I]=p%256>>>0,p=p/256>>>0;if(p!==0)throw new Error("Non-zero carry");u=A,K++}if(d[K]!==" "){for(var S=l-u;S!==l&&f[S]===0;)S++;for(var h=new Uint8Array(x+(l-S)),y=x;S!==l;)h[y++]=f[S++];return h}}}function N(d){var K=v(d);if(K)return K;throw new Error(`Non-${t} character`)}return{encode:b,decodeUnsafe:v,decode:N}}var Xn=Zn,Yn=Xn;class Wn{name;prefix;baseEncode;constructor(t,n,r){this.name=t,this.prefix=n,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class Jn{name;prefix;baseDecode;prefixCodePoint;constructor(t,n,r){this.name=t,this.prefix=n;const s=n.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Ze(this,t)}}class Qn{decoders;constructor(t){this.decoders=t}or(t){return Ze(this,t)}decode(t){const n=t[0],r=this.decoders[n];if(r!=null)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function Ze(e,t){return new Qn({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class tr{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,n,r,s){this.name=t,this.prefix=n,this.baseEncode=r,this.baseDecode=s,this.encoder=new Wn(t,n,r),this.decoder=new Jn(t,n,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function jt({name:e,prefix:t,encode:n,decode:r}){return new tr(e,t,n,r)}function Bt({name:e,prefix:t,alphabet:n}){const{encode:r,decode:s}=Yn(n,e);return jt({prefix:t,name:e,encode:r,decode:i=>zt(s(i))})}function er(e,t,n,r){let s=e.length;for(;e[s-1]==="=";)--s;const i=new Uint8Array(s*n/8|0);let o=0,c=0,a=0;for(let m=0;m<s;++m){const w=t[e[m]];if(w===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<n|w,o+=n,o>=8&&(o-=8,i[a++]=255&c>>o)}if(o>=n||(255&c<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function nr(e,t,n){const r=t[t.length-1]==="=",s=(1<<n)-1;let i="",o=0,c=0;for(let a=0;a<e.length;++a)for(c=c<<8|e[a],o+=8;o>n;)o-=n,i+=t[s&c>>o];if(o!==0&&(i+=t[s&c<<n-o]),r)for(;(i.length*n&7)!==0;)i+="=";return i}function rr(e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=n;return t}function M({name:e,prefix:t,bitsPerChar:n,alphabet:r}){const s=rr(r);return jt({prefix:t,name:e,encode(i){return nr(i,r,n)},decode(i){return er(i,s,n,e)}})}const H=Bt({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),sr=Bt({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),ir=Object.freeze(Object.defineProperty({__proto__:null,base58btc:H,base58flickr:sr},Symbol.toStringTag,{value:"Module"})),Et=M({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),or=M({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ar=M({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),cr=M({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ur=M({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),hr=M({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),fr=M({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),lr=M({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),dr=M({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),yr=Object.freeze(Object.defineProperty({__proto__:null,base32:Et,base32hex:ur,base32hexpad:fr,base32hexpadupper:lr,base32hexupper:hr,base32pad:ar,base32padupper:cr,base32upper:or,base32z:dr},Symbol.toStringTag,{value:"Module"})),Tt=Bt({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),br=Bt({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),wr=Object.freeze(Object.defineProperty({__proto__:null,base36:Tt,base36upper:br},Symbol.toStringTag,{value:"Module"}));var pr=Xe,Ue=128,gr=-128,mr=Math.pow(2,31);function Xe(e,t,n){t=t||[],n=n||0;for(var r=n;e>=mr;)t[n++]=e&255|Ue,e/=128;for(;e&gr;)t[n++]=e&255|Ue,e>>>=7;return t[n]=e|0,Xe.bytes=n-r+1,t}var Ar=re,Sr=128,Ce=127;function re(e,r){var n=0,r=r||0,s=0,i=r,o,c=e.length;do{if(i>=c)throw re.bytes=0,new RangeError("Could not decode varint");o=e[i++],n+=s<28?(o&Ce)<<s:(o&Ce)*Math.pow(2,s),s+=7}while(o>=Sr);return re.bytes=i-r,n}var Er=Math.pow(2,7),xr=Math.pow(2,14),vr=Math.pow(2,21),Kr=Math.pow(2,28),Ir=Math.pow(2,35),_r=Math.pow(2,42),Br=Math.pow(2,49),Ur=Math.pow(2,56),Cr=Math.pow(2,63),Dr=function(e){return e<Er?1:e<xr?2:e<vr?3:e<Kr?4:e<Ir?5:e<_r?6:e<Br?7:e<Ur?8:e<Cr?9:10},Lr={encode:pr,decode:Ar,encodingLength:Dr},Rt=Lr;function se(e,t=0){return[Rt.decode(e,t),Rt.decode.bytes]}function Mt(e,t,n=0){return Rt.encode(e,t,n),t}function Nt(e){return Rt.encodingLength(e)}function pt(e,t){const n=t.byteLength,r=Nt(e),s=r+Nt(n),i=new Uint8Array(s+n);return Mt(e,i,0),Mt(n,i,r),i.set(t,s),new he(e,n,t,i)}function Pr(e){const t=zt(e),[n,r]=se(t),[s,i]=se(t.subarray(r)),o=t.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new he(n,s,o,t)}function Tr(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&Hn(e.bytes,n.bytes)}}class he{code;size;digest;bytes;constructor(t,n,r,s){this.code=t,this.size=n,this.digest=r,this.bytes=s}}function De(e,t){const{bytes:n,version:r}=e;return r===0?Rr(n,ie(e),t??H.encoder):Mr(n,ie(e),t??Et.encoder)}const Le=new WeakMap;function ie(e){const t=Le.get(e);if(t==null){const n=new Map;return Le.set(e,n),n}return t}class L{code;version;multihash;bytes;"/";constructor(t,n,r,s){this.code=n,this.version=t,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:n}=this;if(t!==gt)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(n.code!==Nr)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return L.createV0(n)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:n}=this.multihash,r=pt(t,n);return L.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return L.equals(this,t)}static equals(t,n){const r=n;return r!=null&&t.code===r.code&&t.version===r.version&&Tr(t.multihash,r.multihash)}toString(t){return De(this,t)}toJSON(){return{"/":De(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const n=t;if(n instanceof L)return n;if(n["/"]!=null&&n["/"]===n.bytes||n.asCID===n){const{version:r,code:s,multihash:i,bytes:o}=n;return new L(r,s,i,o??Pe(r,s,i.bytes))}else if(n[$r]===!0){const{version:r,multihash:s,code:i}=n,o=Pr(s);return L.create(r,i,o)}else return null}static create(t,n,r){if(typeof n!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(n!==gt)throw new Error(`Version 0 CID must use dag-pb (code: ${gt}) block encoding`);return new L(t,n,r,r.bytes)}case 1:{const s=Pe(t,n,r.bytes);return new L(t,n,r,s)}default:throw new Error("Invalid version")}}static createV0(t){return L.create(0,gt,t)}static createV1(t,n){return L.create(1,t,n)}static decode(t){const[n,r]=L.decodeFirst(t);if(r.length!==0)throw new Error("Incorrect length");return n}static decodeFirst(t){const n=L.inspectBytes(t),r=n.size-n.multihashSize,s=zt(t.subarray(r,r+n.multihashSize));if(s.byteLength!==n.multihashSize)throw new Error("Incorrect length");const i=s.subarray(n.multihashSize-n.digestSize),o=new he(n.multihashCode,n.digestSize,i,s);return[n.version===0?L.createV0(o):L.createV1(n.codec,o),t.subarray(n.size)]}static inspectBytes(t){let n=0;const r=()=>{const[b,v]=se(t.subarray(n));return n+=v,b};let s=r(),i=gt;if(s===18?(s=0,n=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=n,c=r(),a=r(),m=n+a,w=m-o;return{version:s,codec:i,multihashCode:c,digestSize:a,multihashSize:w,size:m}}static parse(t,n){const[r,s]=kr(t,n),i=L.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return ie(i).set(r,t),i}}function kr(e,t){switch(e[0]){case"Q":{const n=t??H;return[H.prefix,n.decode(`${H.prefix}${e}`)]}case H.prefix:{const n=t??H;return[H.prefix,n.decode(e)]}case Et.prefix:{const n=t??Et;return[Et.prefix,n.decode(e)]}case Tt.prefix:{const n=t??Tt;return[Tt.prefix,n.decode(e)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}}function Rr(e,t,n){const{prefix:r}=n;if(r!==H.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const s=t.get(r);if(s==null){const i=n.encode(e).slice(1);return t.set(r,i),i}else return s}function Mr(e,t,n){const{prefix:r}=n,s=t.get(r);if(s==null){const i=n.encode(e);return t.set(r,i),i}else return s}const gt=112,Nr=18;function Pe(e,t,n){const r=Nt(e),s=r+Nt(t),i=new Uint8Array(s+n.byteLength);return Mt(e,i,0),Mt(t,i,r),i.set(n,s),i}const $r=Symbol.for("@ipld/js-cid/CID"),Ye=0,Or="identity",We=zt;function Fr(e,t){if(t?.truncate!=null&&t.truncate!==e.byteLength){if(t.truncate<0||t.truncate>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,t.truncate)}return pt(Ye,We(e))}const fe={code:Ye,name:Or,encode:We,digest:Fr};function W(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function rt(e=0){return new Uint8Array(e)}function ht(e=0){return new Uint8Array(e)}function wt(e,t){t==null&&(t=e.reduce((s,i)=>s+i.length,0));const n=ht(t);let r=0;for(const s of e)n.set(s,r),r+=s.length;return n}const Je=Symbol.for("@achingbrain/uint8arraylist");function Te(e,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let n=0;for(const r of e){const s=n+r.byteLength;if(t<s)return{buf:r,index:t-n};n=s}throw new RangeError("index is out of bounds")}function Dt(e){return!!e?.[Je]}class V{bufs;length;[Je]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let n=0;for(const r of t)if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.push(r);else if(Dt(r))n+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}prepend(...t){this.prependAll(t)}prependAll(t){let n=0;for(const r of t.reverse())if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.unshift(r);else if(Dt(r))n+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}get(t){const n=Te(this.bufs,t);return n.buf[n.index]}set(t,n){const r=Te(this.bufs,t);r.buf[r.index]=n}write(t,n=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(n+r,t[r]);else if(Dt(t))for(let r=0;r<t.length;r++)this.set(n+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,n){const{bufs:r,length:s}=this._subList(t,n);return wt(r,s)}subarray(t,n){const{bufs:r,length:s}=this._subList(t,n);return r.length===1?r[0]:wt(r,s)}sublist(t,n){const{bufs:r,length:s}=this._subList(t,n),i=new V;return i.length=s,i.bufs=[...r],i}_subList(t,n){if(t=t??0,n=n??this.length,t<0&&(t=this.length+t),n<0&&(n=this.length+n),t<0||n>this.length)throw new RangeError("index is out of bounds");if(t===n)return{bufs:[],length:0};if(t===0&&n===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],c=s,a=c+o.byteLength;if(s=a,t>=a)continue;const m=t>=c&&t<a,w=n>c&&n<=a;if(m&&w){if(t===c&&n===a){r.push(o);break}const b=t-c;r.push(o.subarray(b,b+(n-t)));break}if(m){if(t===0){r.push(o);continue}r.push(o.subarray(t-c));continue}if(w){if(n===a){r.push(o);break}r.push(o.subarray(0,n-c));break}r.push(o)}return{bufs:r,length:n-t}}indexOf(t,n=0){if(!Dt(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=t instanceof Uint8Array?t:t.subarray();if(n=Number(n??0),isNaN(n)&&(n=0),n<0&&(n=this.length+n),n<0&&(n=0),t.length===0)return n>this.length?this.length:n;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let b=0;b<i;b++)o[b]=-1;for(let b=0;b<s;b++)o[r[b]]=b;const c=o,a=this.byteLength-r.byteLength,m=r.byteLength-1;let w;for(let b=n;b<=a;b+=w){w=0;for(let v=m;v>=0;v--){const N=this.get(b+v);if(r[v]!==N){w=Math.max(1,v-c[N]);break}}if(w===0)return b}return-1}getInt8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt8(0)}setInt8(t,n){const r=ht(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,n),this.write(r,t)}getInt16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,n)}setInt16(t,n,r){const s=rt(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,n,r),this.write(s,t)}getInt32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,n)}setInt32(t,n,r){const s=rt(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,n,r),this.write(s,t)}getBigInt64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,n)}setBigInt64(t,n,r){const s=rt(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,n,r),this.write(s,t)}getUint8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint8(0)}setUint8(t,n){const r=ht(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,n),this.write(r,t)}getUint16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,n)}setUint16(t,n,r){const s=rt(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,n,r),this.write(s,t)}getUint32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,n)}setUint32(t,n,r){const s=rt(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,n,r),this.write(s,t)}getBigUint64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,n)}setBigUint64(t,n,r){const s=rt(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,n,r),this.write(s,t)}getFloat32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,n)}setFloat32(t,n,r){const s=rt(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,n,r),this.write(s,t)}getFloat64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,n)}setFloat64(t,n,r){const s=rt(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,n,r),this.write(s,t)}equals(t){if(t==null||!(t instanceof V)||t.bufs.length!==this.bufs.length)return!1;for(let n=0;n<this.bufs.length;n++)if(!W(this.bufs[n],t.bufs[n]))return!1;return!0}static fromUint8Arrays(t,n){const r=new V;return r.bufs=t,n==null&&(n=t.reduce((s,i)=>s+i.byteLength,0)),r.length=n,r}}const Vr=Bt({prefix:"9",name:"base10",alphabet:"0123456789"}),zr=Object.freeze(Object.defineProperty({__proto__:null,base10:Vr},Symbol.toStringTag,{value:"Module"})),jr=M({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Hr=M({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),qr=Object.freeze(Object.defineProperty({__proto__:null,base16:jr,base16upper:Hr},Symbol.toStringTag,{value:"Module"})),Gr=M({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Zr=Object.freeze(Object.defineProperty({__proto__:null,base2:Gr},Symbol.toStringTag,{value:"Module"})),Qe=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Xr=Qe.reduce((e,t,n)=>(e[n]=t,e),[]),Yr=Qe.reduce((e,t,n)=>{const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);return e[r]=n,e},[]);function Wr(e){return e.reduce((t,n)=>(t+=Xr[n],t),"")}function Jr(e){const t=[];for(const n of e){const r=n.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${n}`);const s=Yr[r];if(s==null)throw new Error(`Non-base256emoji character: ${n}`);t.push(s)}return new Uint8Array(t)}const Qr=jt({prefix:"ðŸš€",name:"base256emoji",encode:Wr,decode:Jr}),ts=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Qr},Symbol.toStringTag,{value:"Module"})),es=M({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ns=M({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),rs=M({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ss=M({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),is=Object.freeze(Object.defineProperty({__proto__:null,base64:es,base64pad:ns,base64url:rs,base64urlpad:ss},Symbol.toStringTag,{value:"Module"})),os=M({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),as=Object.freeze(Object.defineProperty({__proto__:null,base8:os},Symbol.toStringTag,{value:"Module"})),cs=jt({prefix:"\0",name:"identity",encode:e=>Gn(e),decode:e=>qn(e)}),us=Object.freeze(Object.defineProperty({__proto__:null,identity:cs},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const hs=20;function fs({name:e,code:t,encode:n,minDigestLength:r,maxDigestLength:s}){return new ls(e,t,n,r,s)}class ls{name;code;encode;minDigestLength;maxDigestLength;constructor(t,n,r,s,i){this.name=t,this.code=n,this.encode=r,this.minDigestLength=s??hs,this.maxDigestLength=i}digest(t,n){if(n?.truncate!=null){if(n.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&n.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const r=this.encode(t);return r instanceof Uint8Array?ke(r,this.code,n?.truncate):r.then(s=>ke(s,this.code,n?.truncate))}else throw Error("Unknown type, must be binary type")}}function ke(e,t,n){if(n!=null&&n!==e.byteLength){if(n>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,n)}return pt(t,e)}function ds(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}const tn=fs({name:"sha2-256",code:18,encode:ds("SHA-256")}),Re={...us,...Zr,...as,...zr,...qr,...yr,...wr,...ir,...is,...ts};function en(e,t,n,r){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:n},decoder:{decode:r}}}const Me=en("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>new TextEncoder().encode(e.substring(1))),Wt=en("ascii","a",e=>{let t="a";for(let n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return t},e=>{e=e.substring(1);const t=ht(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}),nn={utf8:Me,"utf-8":Me,hex:Re.base16,latin1:Wt,ascii:Wt,binary:Wt,...Re};function T(e,t="utf8"){const n=nn[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.decoder.decode(`${n.prefix}${e}`)}function E(e,t="utf8"){const n=nn[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.encoder.encode(e).substring(1)}const ys=parseInt("11111",2),oe=parseInt("10000000",2),bs=parseInt("01111111",2),Ne={0:mt,1:mt,2:ws,3:ms,4:As,5:gs,6:ps,16:mt,22:mt,48:mt};function ct(e,t={offset:0}){const n=e[t.offset]&ys;if(t.offset++,Ne[n]!=null)return Ne[n](e,t);throw new Error("No decoder for tag "+n)}function Ut(e,t){let n=0;if((e[t.offset]&oe)===oe){const r=e[t.offset]&bs;let s="0x";t.offset++;for(let i=0;i<r;i++,t.offset++)s+=e[t.offset].toString(16).padStart(2,"0");n=parseInt(s,16)}else n=e[t.offset],t.offset++;return n}function mt(e,t){Ut(e,t);const n=[];for(;!(t.offset>=e.byteLength);){const r=ct(e,t);if(r===null)break;n.push(r)}return n}function ws(e,t){const n=Ut(e,t),r=t.offset,s=t.offset+n,i=[];for(let o=r;o<s;o++)o===r&&e[o]===0||i.push(e[o]);return t.offset+=n,Uint8Array.from(i)}function ps(e,t){const n=Ut(e,t),r=t.offset+n,s=e[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let c=`${i}.${o}`,a=[];for(;t.offset<r;){const m=e[t.offset];if(t.offset++,a.push(m&127),m<128){a.reverse();let w=0;for(let b=0;b<a.length;b++)w+=a[b]<<b*7;c+=`.${w}`,a=[]}}return c}function gs(e,t){return t.offset++,null}function ms(e,t){const n=Ut(e,t),r=e[t.offset];t.offset++;const s=e.subarray(t.offset,t.offset+n-1);if(t.offset+=n,r!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function As(e,t){const n=Ut(e,t),r=e.subarray(t.offset,t.offset+n);return t.offset+=n,r}function Ss(e){let t=e.toString(16);t.length%2===1&&(t="0"+t);const n=new V;for(let r=0;r<t.length;r+=2)n.append(Uint8Array.from([parseInt(`${t[r]}${t[r+1]}`,16)]));return n}function Ht(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=Ss(e.byteLength);return new V(Uint8Array.from([t.byteLength|oe]),t)}function j(e){const t=new V,n=128;return(e.subarray()[0]&n)===n&&t.append(Uint8Array.from([0])),t.append(e),new V(Uint8Array.from([2]),Ht(t),t)}function le(e){const t=Uint8Array.from([0]),n=new V(t,e);return new V(Uint8Array.from([3]),Ht(n),n)}function Es(e){return new V(Uint8Array.from([4]),Ht(e),e)}function tt(e,t=48){const n=new V;for(const r of e)n.append(r);return new V(Uint8Array.from([t]),Ht(n),n)}const rn="1.2.840.10045.3.1.7",sn="1.3.132.0.34",on="1.3.132.0.35";async function xs(e="P-256"){const t=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:e},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",t.publicKey),privateKey:await crypto.subtle.exportKey("jwk",t.privateKey)}}async function vs(e,t,n){const r=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["sign"]);n?.signal?.throwIfAborted();const s=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r,t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function Ks(e,t,n,r){const s=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);r?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,n.subarray());return r?.signal?.throwIfAborted(),i}const Is=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),_s=Uint8Array.from([6,5,43,129,4,0,34]),Bs=Uint8Array.from([6,5,43,129,4,0,35]),an={ext:!0,kty:"EC",crv:"P-256"},cn={ext:!0,kty:"EC",crv:"P-384"},un={ext:!0,kty:"EC",crv:"P-521"},lt=32,dt=48,yt=66;function Us(e){const t=ct(e);return hn(t)}function hn(e){const t=e[1],n=E(t,"base64url"),r=e[2][1][0],s=1;let i,o;if(t.byteLength===lt)return i=E(r.subarray(s,s+lt),"base64url"),o=E(r.subarray(s+lt),"base64url"),new xt({...an,key_ops:["sign"],d:n,x:i,y:o});if(t.byteLength===dt)return i=E(r.subarray(s,s+dt),"base64url"),o=E(r.subarray(s+dt),"base64url"),new xt({...cn,key_ops:["sign"],d:n,x:i,y:o});if(t.byteLength===yt)return i=E(r.subarray(s,s+yt),"base64url"),o=E(r.subarray(s+yt),"base64url"),new xt({...un,key_ops:["sign"],d:n,x:i,y:o});throw new _(`Private key length was wrong length, got ${t.byteLength}, expected 32, 48 or 66`)}function fn(e){const t=ct(e);return ln(t)}function ln(e){const t=e[1][1][0],n=1;let r,s;if(t.byteLength===lt*2+1)return r=E(t.subarray(n,n+lt),"base64url"),s=E(t.subarray(n+lt),"base64url"),new kt({...an,key_ops:["verify"],x:r,y:s});if(t.byteLength===dt*2+1)return r=E(t.subarray(n,n+dt),"base64url"),s=E(t.subarray(n+dt),"base64url"),new kt({...cn,key_ops:["verify"],x:r,y:s});if(t.byteLength===yt*2+1)return r=E(t.subarray(n,n+yt),"base64url"),s=E(t.subarray(n+yt),"base64url"),new kt({...un,key_ops:["verify"],x:r,y:s});throw new _(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function Cs(e){return tt([j(Uint8Array.from([1])),Es(T(e.d??"","base64url")),tt([dn(e.crv)],160),tt([le(new V(Uint8Array.from([4]),T(e.x??"","base64url"),T(e.y??"","base64url")))],161)]).subarray()}function Ds(e){return tt([j(Uint8Array.from([1])),tt([dn(e.crv)],160),tt([le(new V(Uint8Array.from([4]),T(e.x??"","base64url"),T(e.y??"","base64url")))],161)]).subarray()}function dn(e){if(e==="P-256")return Is;if(e==="P-384")return _s;if(e==="P-521")return Bs;throw new _(`Invalid curve ${e}`)}async function Ls(e="P-256"){const t=await xs(e);return new xt(t.privateKey)}class kt{type="ECDSA";jwk;_raw;constructor(t){this.jwk=t}get raw(){return this._raw==null&&(this._raw=Ds(this.jwk)),this._raw}toMultihash(){return fe.digest(Zt(this))}toCID(){return L.createV1(114,this.toMultihash())}toString(){return H.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}async verify(t,n,r){return Ks(this.jwk,n,t,r)}}class xt{type="ECDSA";jwk;publicKey;_raw;constructor(t){this.jwk=t,this.publicKey=new kt({crv:t.crv,ext:t.ext,key_ops:["verify"],kty:"EC",x:t.x,y:t.y})}get raw(){return this._raw==null&&(this._raw=Cs(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}async sign(t,n){return vs(this.jwk,t,n)}}const st=BigInt(0),R=BigInt(1),Jt=BigInt(2),Ps=BigInt(8);function Ts(e,t,n,r){const s=e.sqr(n),i=e.sqr(r),o=e.add(e.mul(t.a,s),i),c=e.add(e.ONE,e.mul(t.d,e.mul(s,i)));return e.eql(o,c)}function ks(e,t={}){const n=$n("edwards",e,t,t.FpFnLE),{Fp:r,Fn:s}=n;let i=n.CURVE;const{h:o}=i;He(t,{},{uvRatio:"function"});const c=Jt<<BigInt(s.BYTES*8)-R,a=x=>r.create(x),m=t.uvRatio||((x,u)=>{try{return{isValid:!0,value:r.sqrt(r.div(x,u))}}catch{return{isValid:!1,value:st}}});if(!Ts(r,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function w(x,u,l=!1){const f=l?R:st;return _e("coordinate "+x,u,f,c),u}function b(x){if(!(x instanceof d))throw new Error("EdwardsPoint expected")}const v=Be((x,u)=>{const{X:l,Y:f,Z:p}=x,A=x.is0();u==null&&(u=A?Ps:r.inv(p));const I=a(l*u),S=a(f*u),h=r.mul(p,u);if(A)return{x:st,y:R};if(h!==R)throw new Error("invZ was invalid");return{x:I,y:S}}),N=Be(x=>{const{a:u,d:l}=i;if(x.is0())throw new Error("bad point: ZERO");const{X:f,Y:p,Z:A,T:I}=x,S=a(f*f),h=a(p*p),y=a(A*A),g=a(y*y),B=a(S*u),D=a(y*a(B+h)),C=a(g+a(l*a(S*h)));if(D!==C)throw new Error("bad point: equation left != right (1)");const P=a(f*p),z=a(A*I);if(P!==z)throw new Error("bad point: equation left != right (2)");return!0});class d{static BASE=new d(i.Gx,i.Gy,R,a(i.Gx*i.Gy));static ZERO=new d(st,R,R,st);static Fp=r;static Fn=s;X;Y;Z;T;constructor(u,l,f,p){this.X=w("x",u),this.Y=w("y",l),this.Z=w("z",f,!0),this.T=w("t",p),Object.freeze(this)}static CURVE(){return i}static fromAffine(u){if(u instanceof d)throw new Error("extended point not allowed");const{x:l,y:f}=u||{};return w("x",l),w("y",f),new d(l,f,R,a(l*f))}static fromBytes(u,l=!1){const f=r.BYTES,{a:p,d:A}=i;u=Ie(Z(u,f,"point")),ee(l,"zip215");const I=Ie(u),S=u[f-1];I[f-1]=S&-129;const h=ne(I),y=l?c:r.ORDER;_e("point.y",h,st,y);const g=a(h*h),B=a(g-R),D=a(A*g-p);let{isValid:C,value:P}=m(B,D);if(!C)throw new Error("bad point: invalid y coordinate");const z=(P&R)===R,q=(S&128)!==0;if(!l&&P===st&&q)throw new Error("bad point: x=0 and x_0=1");return q!==z&&(P=a(-P)),d.fromAffine({x:P,y:h})}static fromHex(u,l=!1){return d.fromBytes(On(u),l)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(u=8,l=!0){return K.createCache(this,u),l||this.multiply(Jt),this}assertValidity(){N(this)}equals(u){b(u);const{X:l,Y:f,Z:p}=this,{X:A,Y:I,Z:S}=u,h=a(l*S),y=a(A*p),g=a(f*S),B=a(I*p);return h===y&&g===B}is0(){return this.equals(d.ZERO)}negate(){return new d(a(-this.X),this.Y,this.Z,a(-this.T))}double(){const{a:u}=i,{X:l,Y:f,Z:p}=this,A=a(l*l),I=a(f*f),S=a(Jt*a(p*p)),h=a(u*A),y=l+f,g=a(a(y*y)-A-I),B=h+I,D=B-S,C=h-I,P=a(g*D),z=a(B*C),q=a(g*C),J=a(D*B);return new d(P,z,J,q)}add(u){b(u);const{a:l,d:f}=i,{X:p,Y:A,Z:I,T:S}=this,{X:h,Y:y,Z:g,T:B}=u,D=a(p*h),C=a(A*y),P=a(S*f*B),z=a(I*g),q=a((p+A)*(h+y)-D-C),J=z-P,Q=z+P,ft=a(C-l*D),Ct=a(q*J),Xt=a(Q*ft),xe=a(q*ft),ve=a(J*Q);return new d(Ct,Xt,ve,xe)}subtract(u){return this.add(u.negate())}multiply(u){if(!s.isValidNot0(u))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:l,f}=K.cached(this,u,p=>Yt(d,p));return Yt(d,[l,f])[0]}multiplyUnsafe(u,l=d.ZERO){if(!s.isValid(u))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return u===st?d.ZERO:this.is0()||u===R?this:K.unsafe(this,u,f=>Yt(d,f),l)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return K.unsafe(this,i.n).is0()}toAffine(u){return v(this,u)}clearCofactor(){return o===R?this:this.multiplyUnsafe(o)}toBytes(){const{x:u,y:l}=this.toAffine(),f=r.toBytes(l);return f[f.length-1]|=u&R?128:0,f}toHex(){return Vn(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const K=new Fn(d,s.BITS);return d.BASE.precompute(8),d}function Rs(e,t,n={}){if(typeof t!="function")throw new Error('"hash" function param is required');He(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:s,Fp:i,Fn:o}=e,c=n.randomBytes||Rn,a=n.adjustScalarBytes||(h=>h),m=n.domain||((h,y,g)=>{if(ee(g,"phflag"),y.length||g)throw new Error("Contexts/pre-hash are not supported");return h});function w(h){return o.create(ne(h))}function b(h){const y=f.secretKey;Z(h,f.secretKey,"secretKey");const g=Z(t(h),2*y,"hashedSecretKey"),B=a(g.slice(0,y)),D=g.slice(y,2*y),C=w(B);return{head:B,prefix:D,scalar:C}}function v(h){const{head:y,prefix:g,scalar:B}=b(h),D=s.multiply(B),C=D.toBytes();return{head:y,prefix:g,scalar:B,point:D,pointBytes:C}}function N(h){return v(h).pointBytes}function d(h=Uint8Array.of(),...y){const g=Ke(...y);return w(t(m(g,Z(h,void 0,"context"),!!r)))}function K(h,y,g={}){h=Z(h,void 0,"message"),r&&(h=r(h));const{prefix:B,scalar:D,pointBytes:C}=v(y),P=d(g.context,B,h),z=s.multiply(P).toBytes(),q=d(g.context,z,C,h),J=o.create(P+q*D);if(!o.isValid(J))throw new Error("sign failed: invalid s");const Q=Ke(z,o.toBytes(J));return Z(Q,f.signature,"result")}const x={zip215:!0};function u(h,y,g,B=x){const{context:D,zip215:C}=B,P=f.signature;h=Z(h,P,"signature"),y=Z(y,void 0,"message"),g=Z(g,f.publicKey,"publicKey"),C!==void 0&&ee(C,"zip215"),r&&(y=r(y));const z=P/2,q=h.subarray(0,z),J=ne(h.subarray(z,P));let Q,ft,Ct;try{Q=e.fromBytes(g,C),ft=e.fromBytes(q,C),Ct=s.multiplyUnsafe(J)}catch{return!1}if(!C&&Q.isSmallOrder())return!1;const Xt=d(D,ft.toBytes(),Q.toBytes(),y);return ft.add(Q.multiplyUnsafe(Xt)).subtract(Ct).clearCofactor().is0()}const l=i.BYTES,f={secretKey:l,publicKey:l,signature:2*l,seed:l};function p(h=c(f.seed)){return Z(h,f.seed,"seed")}function A(h){return Nn(h)&&h.length===o.BYTES}function I(h,y){try{return!!e.fromBytes(h,y)}catch{return!1}}const S={getExtendedPublicKey:v,randomSecretKey:p,isValidSecretKey:A,isValidPublicKey:I,toMontgomery(h){const{y}=e.fromBytes(h),g=f.publicKey,B=g===32;if(!B&&g!==57)throw new Error("only defined for 25519 and 448");const D=B?i.div(R+y,R-y):i.div(y-R,y+R);return i.toBytes(D)},toMontgomerySecret(h){const y=f.secretKey;Z(h,y);const g=t(h.subarray(0,y));return a(g).subarray(0,y)}};return Object.freeze({keygen:Mn(p,N),getPublicKey:N,sign:K,verify:u,utils:S,Point:e,lengths:f})}const Ms=BigInt(1),$e=BigInt(2),Ns=BigInt(5),$s=BigInt(8),de=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Os={p:de,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:$s,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Fs(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),s=BigInt(80),i=de,c=e*e%i*e%i,a=X(c,$e,i)*c%i,m=X(a,Ms,i)*e%i,w=X(m,Ns,i)*m%i,b=X(w,t,i)*w%i,v=X(b,n,i)*b%i,N=X(v,r,i)*v%i,d=X(N,s,i)*N%i,K=X(d,s,i)*N%i,x=X(K,t,i)*w%i;return{pow_p_5_8:X(x,$e,i)*e%i,b2:c}}function Vs(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Oe=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function zs(e,t){const n=de,r=nt(t*t*t,n),s=nt(r*r*t,n),i=Fs(e*s).pow_p_5_8;let o=nt(e*r*i,n);const c=nt(t*o*o,n),a=o,m=nt(o*Oe,n),w=c===e,b=c===nt(-e,n),v=c===nt(-e*Oe,n);return w&&(o=a),(b||v)&&(o=m),jn(o,n)&&(o=nt(-o,n)),{isValid:w||b,value:o}}const js=ks(Os,{uvRatio:zs});function Hs(e){return Rs(js,zn,Object.assign({adjustScalarBytes:Vs},e))}const vt=Hs({});class Fe extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}}class Ve extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class qs extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const k={get(e=globalThis){const t=e.crypto;if(t?.subtle==null)throw new qs("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},Kt=32,Y=64,$t=32;let bt;const yn=(async()=>{try{return await k.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function Gs(){const e=vt.utils.randomSecretKey(),t=vt.getPublicKey(e);return{privateKey:bn(e,t),publicKey:t}}function Zs(e){if(e.length!==$t)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=vt.getPublicKey(t);return{privateKey:bn(t,n),publicKey:n}}async function Xs(e,t){let n;e.length===Y?n=e.subarray(0,32):n=e;const r={crv:"Ed25519",kty:"OKP",x:E(e.subarray(32),"base64url"),d:E(n,"base64url"),ext:!0,key_ops:["sign"]},s=await k.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),i=await k.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}function Ys(e,t){const n=e.subarray(0,$t);return vt.sign(t instanceof Uint8Array?t:t.subarray(),n)}async function Ws(e,t){return bt==null&&(bt=await yn),bt?Xs(e,t):Ys(e,t)}async function Js(e,t,n){if(e.buffer instanceof ArrayBuffer){const r=await k.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await k.get().subtle.verify({name:"Ed25519"},r,t,n instanceof Uint8Array?n:n.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Qs(e,t,n){return vt.verify(t,n instanceof Uint8Array?n:n.subarray(),e)}async function ti(e,t,n){return bt==null&&(bt=await yn),bt?Js(e,t,n):Qs(e,t,n)}function bn(e,t){const n=new Uint8Array(Y);for(let r=0;r<$t;r++)n[r]=e[r],n[$t+r]=t[r];return n}function ze(e,t){let n=T(e,"base64urlpad");if(t!=null){if(n.length>t)throw new Error("byte array longer than desired length");n=wt([new Uint8Array(t-n.length),n])}return n}function qt(e){return e==null?!1:typeof e.then=="function"&&typeof e.catch=="function"&&typeof e.finally=="function"}class wn{type="Ed25519";raw;constructor(t){this.raw=It(t,Kt)}toMultihash(){return fe.digest(Zt(this))}toCID(){return L.createV1(114,this.toMultihash())}toString(){return H.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}verify(t,n,r){r?.signal?.throwIfAborted();const s=ti(this.raw,n,t);return qt(s)?s.then(i=>(r?.signal?.throwIfAborted(),i)):s}}class Ot{type="Ed25519";raw;publicKey;constructor(t,n){this.raw=It(t,Y),this.publicKey=new wn(n)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}sign(t,n){n?.signal?.throwIfAborted();const r=Ws(this.raw,t);return qt(r)?r.then(s=>(n?.signal?.throwIfAborted(),s)):(n?.signal?.throwIfAborted(),r)}}function pn(e){if(e.length>Y){e=It(e,Y+Kt);const r=e.subarray(0,Y),s=e.subarray(Y,e.length);return new Ot(r,s)}e=It(e,Y);const t=e.subarray(0,Y),n=e.subarray(Kt);return new Ot(t,n)}function ye(e){return e=It(e,Kt),new wn(e)}async function ei(){const{privateKey:e,publicKey:t}=Gs();return new Ot(e,t)}async function ni(e){const{privateKey:t,publicKey:n}=Zs(e);return new Ot(t,n)}function It(e,t){if(e=Uint8Array.from(e??[]),e.length!==t)throw new _(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}const ri=Math.pow(2,7),si=Math.pow(2,14),ii=Math.pow(2,21),gn=Math.pow(2,28),mn=Math.pow(2,35),An=Math.pow(2,42),Sn=Math.pow(2,49),F=128,it=127;function be(e){if(e<ri)return 1;if(e<si)return 2;if(e<ii)return 3;if(e<gn)return 4;if(e<mn)return 5;if(e<An)return 6;if(e<Sn)return 7;if(Number.MAX_SAFE_INTEGER!=null&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function oi(e,t,n=0){switch(be(e)){case 8:t[n++]=e&255|F,e/=128;case 7:t[n++]=e&255|F,e/=128;case 6:t[n++]=e&255|F,e/=128;case 5:t[n++]=e&255|F,e/=128;case 4:t[n++]=e&255|F,e>>>=7;case 3:t[n++]=e&255|F,e>>>=7;case 2:t[n++]=e&255|F,e>>>=7;case 1:{t[n++]=e&255,e>>>=7;break}default:throw new Error("unreachable")}return t}function ai(e,t){let n=e[t],r=0;if(r+=n&it,n<F||(n=e[t+1],r+=(n&it)<<7,n<F)||(n=e[t+2],r+=(n&it)<<14,n<F)||(n=e[t+3],r+=(n&it)<<21,n<F)||(n=e[t+4],r+=(n&it)*gn,n<F)||(n=e[t+5],r+=(n&it)*mn,n<F)||(n=e[t+6],r+=(n&it)*An,n<F)||(n=e[t+7],r+=(n&it)*Sn,n<F))return r;throw new RangeError("Could not decode varint")}const we=new Float32Array([-0]),ot=new Uint8Array(we.buffer);function ci(e,t,n){we[0]=e,t[n]=ot[0],t[n+1]=ot[1],t[n+2]=ot[2],t[n+3]=ot[3]}function ui(e,t){return ot[0]=e[t],ot[1]=e[t+1],ot[2]=e[t+2],ot[3]=e[t+3],we[0]}const pe=new Float64Array([-0]),$=new Uint8Array(pe.buffer);function hi(e,t,n){pe[0]=e,t[n]=$[0],t[n+1]=$[1],t[n+2]=$[2],t[n+3]=$[3],t[n+4]=$[4],t[n+5]=$[5],t[n+6]=$[6],t[n+7]=$[7]}function fi(e,t){return $[0]=e[t],$[1]=e[t+1],$[2]=e[t+2],$[3]=e[t+3],$[4]=e[t+4],$[5]=e[t+5],$[6]=e[t+6],$[7]=e[t+7],pe[0]}const li=BigInt(Number.MAX_SAFE_INTEGER),di=BigInt(Number.MIN_SAFE_INTEGER);class O{lo;hi;constructor(t,n){this.lo=t|0,this.hi=n|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(n+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(BigInt(n)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,n=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?n===0?t<16384?t<128?1:2:t<2097152?3:4:n<16384?n<128?5:6:n<2097152?7:8:r<128?9:10}static fromBigInt(t){if(t===0n)return ut;if(t<li&&t>di)return this.fromNumber(Number(t));const n=t<0n;n&&(t=-t);let r=t>>32n,s=t-(r<<32n);return n&&(r=~r|0n,s=~s|0n,++s>je&&(s=0n,++r>je&&(r=0n))),new O(Number(s),Number(r))}static fromNumber(t){if(t===0)return ut;const n=t<0;n&&(t=-t);let r=t>>>0,s=(t-r)/4294967296>>>0;return n&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new O(r,s)}static from(t){return typeof t=="number"?O.fromNumber(t):typeof t=="bigint"?O.fromBigInt(t):typeof t=="string"?O.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new O(t.low>>>0,t.high>>>0):ut}}const ut=new O(0,0);ut.toBigInt=function(){return 0n};ut.zzEncode=ut.zzDecode=function(){return this};ut.length=function(){return 1};const je=4294967296n;function yi(e){let t=0,n=0;for(let r=0;r<e.length;++r)n=e.charCodeAt(r),n<128?t+=1:n<2048?t+=2:(n&64512)===55296&&(e.charCodeAt(r+1)&64512)===56320?(++r,t+=4):t+=3;return t}function bi(e,t,n){if(n-t<1)return"";let s;const i=[];let o=0,c;for(;t<n;)c=e[t++],c<128?i[o++]=c:c>191&&c<224?i[o++]=(c&31)<<6|e[t++]&63:c>239&&c<365?(c=((c&7)<<18|(e[t++]&63)<<12|(e[t++]&63)<<6|e[t++]&63)-65536,i[o++]=55296+(c>>10),i[o++]=56320+(c&1023)):i[o++]=(c&15)<<12|(e[t++]&63)<<6|e[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function En(e,t,n){const r=n;let s,i;for(let o=0;o<e.length;++o)s=e.charCodeAt(o),s<128?t[n++]=s:s<2048?(t[n++]=s>>6|192,t[n++]=s&63|128):(s&64512)===55296&&((i=e.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[n++]=s>>18|240,t[n++]=s>>12&63|128,t[n++]=s>>6&63|128,t[n++]=s&63|128):(t[n++]=s>>12|224,t[n++]=s>>6&63|128,t[n++]=s&63|128);return n-r}function G(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function Lt(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class wi{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,G(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw G(this,4);return Lt(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw G(this,4);return Lt(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw G(this,4);const t=ui(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw G(this,4);const t=fi(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),n=this.pos,r=this.pos+t;if(r>this.len)throw G(this,t);return this.pos+=t,n===r?new Uint8Array(0):this.buf.subarray(n,r)}string(){const t=this.bytes();return bi(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw G(this,t);this.pos+=t}else do if(this.pos>=this.len)throw G(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new O(0,0);let n=0;if(this.len-this.pos>4){for(;n<4;++n)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;n=0}else{for(;n<3;++n){if(this.pos>=this.len)throw G(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<n*7)>>>0,t}if(this.len-this.pos>4){for(;n<5;++n)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;n<5;++n){if(this.pos>=this.len)throw G(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw G(this,8);const t=Lt(this.buf,this.pos+=4),n=Lt(this.buf,this.pos+=4);return new O(t,n)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=ai(this.buf,this.pos);return this.pos+=be(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function pi(e){return new wi(e instanceof Uint8Array?e:e.subarray())}function xn(e,t,n){const r=pi(e);return t.decode(r,void 0,n)}function gi(e){let r,s=8192;return function(o){if(o<1||o>4096)return ht(o);s+o>8192&&(r=ht(8192),s=0);const c=r.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),c}}class St{fn;len;next;val;constructor(t,n,r){this.fn=t,this.len=n,this.next=void 0,this.val=r}}function Qt(){}class mi{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const Ai=gi();function Si(e){return globalThis.Buffer!=null?ht(e):Ai(e)}class ae{len;head;tail;states;constructor(){this.len=0,this.head=new St(Qt,0,0),this.tail=this.head,this.states=null}_push(t,n,r){return this.tail=this.tail.next=new St(t,n,r),this.len+=n,this}uint32(t){return this.len+=(this.tail=this.tail.next=new xi((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Pt,10,O.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const n=O.fromBigInt(t);return this._push(Pt,n.length(),n)}uint64Number(t){return this._push(oi,be(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const n=O.fromBigInt(t).zzEncode();return this._push(Pt,n.length(),n)}sint64Number(t){const n=O.fromNumber(t).zzEncode();return this._push(Pt,n.length(),n)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(te,1,t?1:0)}fixed32(t){return this._push(At,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const n=O.fromBigInt(t);return this._push(At,4,n.lo)._push(At,4,n.hi)}fixed64Number(t){const n=O.fromNumber(t);return this._push(At,4,n.lo)._push(At,4,n.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(ci,4,t)}double(t){return this._push(hi,8,t)}bytes(t){const n=t.length>>>0;return n===0?this._push(te,1,0):this.uint32(n)._push(vi,n,t)}string(t){const n=yi(t);return n!==0?this.uint32(n)._push(En,n,t):this._push(te,1,0)}fork(){return this.states=new mi(this),this.head=this.tail=new St(Qt,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new St(Qt,0,0),this.len=0),this}ldelim(){const t=this.head,n=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=t.next,this.tail=n,this.len+=r),this}finish(){let t=this.head.next;const n=Si(this.len);let r=0;for(;t!=null;)t.fn(t.val,n,r),r+=t.len,t=t.next;return n}}function te(e,t,n){t[n]=e&255}function Ei(e,t,n){for(;e>127;)t[n++]=e&127|128,e>>>=7;t[n]=e}class xi extends St{next;constructor(t,n){super(Ei,t,n),this.next=void 0}}function Pt(e,t,n){for(;e.hi!==0;)t[n++]=e.lo&127|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=e.lo&127|128,e.lo=e.lo>>>7;t[n++]=e.lo}function At(e,t,n){t[n]=e&255,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function vi(e,t,n){t.set(e,n)}globalThis.Buffer!=null&&(ae.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(Ki,t,e),this},ae.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(Ii,t,e),this});function Ki(e,t,n){t.set(e,n)}function Ii(e,t,n){e.length<40?En(e,t,n):t.utf8Write!=null?t.utf8Write(e,n):t.set(T(e),n)}function _i(){return new ae}function vn(e,t){const n=_i();return t.encode(e,n,{lengthDelimited:!1}),n.finish()}var Ft;(function(e){e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(Ft||(Ft={}));function Kn(e,t,n,r){return{name:e,type:t,encode:n,decode:r}}function Bi(e){function t(s){if(e[s.toString()]==null)throw new Error("Invalid enum value");return e[s]}const n=function(i,o){const c=t(i);o.int32(c)},r=function(i){const o=i.int32();return t(o)};return Kn("enum",Ft.VARINT,n,r)}function In(e,t){return Kn("message",Ft.LENGTH_DELIMITED,e,t)}var U;(function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(U||(U={}));var ce;(function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})(ce||(ce={}));(function(e){e.codec=()=>Bi(ce)})(U||(U={}));var at;(function(e){let t;e.codec=()=>(t==null&&(t=In((n,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),U.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),s.lengthDelimited!==!1&&r.ldelim()},(n,r,s={})=>{const i={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const c=n.uint32();switch(c>>>3){case 1:{i.Type=U.codec().decode(n);break}case 2:{i.Data=n.bytes();break}default:{n.skipType(c&7);break}}}return i})),t),e.encode=n=>vn(n,e.codec()),e.decode=(n,r)=>xn(n,e.codec(),r)})(at||(at={}));var Vt;(function(e){let t;e.codec=()=>(t==null&&(t=In((n,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),U.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),s.lengthDelimited!==!1&&r.ldelim()},(n,r,s={})=>{const i={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const c=n.uint32();switch(c>>>3){case 1:{i.Type=U.codec().decode(n);break}case 2:{i.Data=n.bytes();break}default:{n.skipType(c&7);break}}}return i})),t),e.encode=n=>vn(n,e.codec()),e.decode=(n,r)=>xn(n,e.codec(),r)})(Vt||(Vt={}));class ge{type="RSA";jwk;_raw;_multihash;constructor(t,n){this.jwk=t,this._multihash=n}get raw(){return this._raw==null&&(this._raw=Ae(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return L.createV1(114,this._multihash)}toString(){return H.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}verify(t,n,r){return Fi(this.jwk,n,t,r)}}class _n{type="RSA";jwk;_raw;publicKey;constructor(t,n){this.jwk=t,this.publicKey=n}get raw(){return this._raw==null&&(this._raw=Li(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}sign(t,n){return Oi(this.jwk,t,n)}}const Bn=8192,me=18,Ui=1062,Ci=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Di(e){return{n:E(e[1],"base64url"),e:E(e[2],"base64url"),d:E(e[3],"base64url"),p:E(e[4],"base64url"),q:E(e[5],"base64url"),dp:E(e[6],"base64url"),dq:E(e[7],"base64url"),qi:E(e[8],"base64url"),kty:"RSA"}}function Li(e){if(e.n==null||e.e==null||e.d==null||e.p==null||e.q==null||e.dp==null||e.dq==null||e.qi==null)throw new _("JWK was missing components");return tt([j(Uint8Array.from([0])),j(T(e.n,"base64url")),j(T(e.e,"base64url")),j(T(e.d,"base64url")),j(T(e.p,"base64url")),j(T(e.q,"base64url")),j(T(e.dp,"base64url")),j(T(e.dq,"base64url")),j(T(e.qi,"base64url"))]).subarray()}function Pi(e){const t=ct(e[1],{offset:0});return{kty:"RSA",n:E(t[0],"base64url"),e:E(t[1],"base64url")}}function Ae(e){if(e.n==null||e.e==null)throw new _("JWK was missing components");return tt([Ci,le(tt([j(T(e.n,"base64url")),j(T(e.e,"base64url"))]))]).subarray()}function Ti(e){const t=ct(e);return Un(t)}function Un(e){const t=Di(e);return Dn(t)}function ki(e,t){if(e.byteLength>=Ui)throw new qe("Key size is too large");const n=ct(e,{offset:0});return Cn(n,e,t)}function Cn(e,t,n){const r=Pi(e);if(n==null){const s=ue(at.encode({Type:U.RSA,Data:t}));n=pt(me,s)}return new ge(r,n)}function Dn(e){if(zi(e)>Bn)throw new _("Key size is too large");const t=Mi(e),n=ue(at.encode({Type:U.RSA,Data:Ae(t.publicKey)})),r=pt(me,n);return new _n(t.privateKey,new ge(t.publicKey,r))}async function Ri(e){if(e>Bn)throw new _("Key size is too large");const t=await $i(e),n=ue(at.encode({Type:U.RSA,Data:Ae(t.publicKey)})),r=pt(me,n);return new _n(t.privateKey,new ge(t.publicKey,r))}function Mi(e){if(e==null)throw new _("Missing key parameter");return{privateKey:e,publicKey:{kty:e.kty,n:e.n,e:e.e}}}const Ni="1.2.840.113549.1.1.1";async function $i(e,t){const n=await k.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),r=await Vi(n);return{privateKey:r[0],publicKey:r[1]}}async function Oi(e,t,n){const r=await k.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);n?.signal?.throwIfAborted();const s=await k.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},r,t instanceof Uint8Array?t:t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function Fi(e,t,n,r){const s=await k.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);r?.signal?.throwIfAborted();const i=await k.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,n instanceof Uint8Array?n:n.subarray());return r?.signal?.throwIfAborted(),i}async function Vi(e,t){if(e.privateKey==null||e.publicKey==null)throw new _("Private and public key are required");return await Promise.all([k.get().subtle.exportKey("jwk",e.privateKey),k.get().subtle.exportKey("jwk",e.publicKey)])}function zi(e){if(e.kty!=="RSA")throw new _("invalid key type");if(e.n==null)throw new _("invalid key modulus");return T(e.n,"base64url").length*8}const ji=33,Hi=32;function qi(e,t,n){const r=tn.digest(t instanceof Uint8Array?t:t.subarray());if(qt(r))return r.then(({digest:s})=>(n?.signal?.throwIfAborted(),et.sign(s,e,{prehash:!1,format:"der"}))).catch(s=>{throw s.name==="AbortError"?s:new Fe(String(s))});try{return et.sign(r.digest,e,{prehash:!1,format:"der"})}catch(s){throw new Fe(String(s))}}function Gi(e,t,n,r){const s=tn.digest(n instanceof Uint8Array?n:n.subarray());if(qt(s))return s.then(({digest:i})=>(r?.signal?.throwIfAborted(),et.verify(t,i,e,{prehash:!1,format:"der"}))).catch(i=>{throw i.name==="AbortError"?i:new Ve(String(i))});try{return r?.signal?.throwIfAborted(),et.verify(t,s.digest,e,{prehash:!1,format:"der"})}catch(i){throw new Ve(String(i))}}class Ln{type="secp256k1";raw;_key;constructor(t){this._key=Wi(t),this.raw=Xi(this._key)}toMultihash(){return fe.digest(Zt(this))}toCID(){return L.createV1(114,this.toMultihash())}toString(){return H.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}verify(t,n,r){return Gi(this._key,n,t,r)}}class Pn{type="secp256k1";raw;publicKey;constructor(t,n){this.raw=Yi(t),this.publicKey=new Ln(n??Ji(t))}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:W(this.raw,t.raw)}sign(t,n){return qi(this.raw,t,n)}}function Tn(e){return new Pn(e)}function Se(e){return new Ln(e)}async function Zi(){const e=Qi();return new Pn(e)}function Xi(e){return et.Point.fromBytes(e).toBytes()}function Yi(e){try{return et.getPublicKey(e,!0),e}catch(t){throw new Ge(String(t))}}function Wi(e){try{return et.Point.fromBytes(e),e}catch(t){throw new qe(String(t))}}function Ji(e){try{return et.getPublicKey(e,!0)}catch(t){throw new Ge(String(t))}}function Qi(){return et.utils.randomSecretKey()}const Gt={"P-256":32,"P-384":48,"P-521":66},to=Object.keys(Gt),Ee=to.join(" / ");async function eo(e){if(e!=="P-256"&&e!=="P-384"&&e!=="P-521")throw new _(`Unknown curve: ${e}. Must be ${Ee}`);const t=await k.get().subtle.generateKey({name:"ECDH",namedCurve:e},!0,["deriveBits"]),n=async(i,o)=>{let c;o!=null?c=await k.get().subtle.importKey("jwk",ro(e,o),{name:"ECDH",namedCurve:e},!1,["deriveBits"]):c=t.privateKey;const a=await k.get().subtle.importKey("jwk",kn(e,i),{name:"ECDH",namedCurve:e},!1,[]),m=await k.get().subtle.deriveBits({name:"ECDH",public:a},c,Gt[e]*8);return new Uint8Array(m,0,m.byteLength)},r=await k.get().subtle.exportKey("jwk",t.publicKey);return{key:no(r),genSharedKey:n}}function no(e){if(e.crv==null||e.x==null||e.y==null)throw new _("JWK was missing components");if(e.crv!=="P-256"&&e.crv!=="P-384"&&e.crv!=="P-521")throw new _(`Unknown curve: ${e.crv}. Must be ${Ee}`);const t=Gt[e.crv];return wt([Uint8Array.from([4]),ze(e.x,t),ze(e.y,t)],1+t*2)}function kn(e,t){if(e!=="P-256"&&e!=="P-384"&&e!=="P-521")throw new _(`Unknown curve: ${e}. Must be ${Ee}`);const n=Gt[e];if(!W(t.subarray(0,1),Uint8Array.from([4])))throw new _("Cannot unmarshal public key - invalid key format");return{kty:"EC",crv:e,x:E(t.subarray(1,n+1),"base64url"),y:E(t.subarray(1+n),"base64url"),ext:!0}}const ro=(e,t)=>({...kn(e,t.public),d:E(t.private,"base64url")}),so={SHA1:20,SHA256:32,SHA512:64},io={SHA1:"SHA-1",SHA256:"SHA-256",SHA512:"SHA-512"},oo=async(e,t)=>{const n=await k.get().subtle.sign({name:"HMAC"},e,t);return new Uint8Array(n,0,n.byteLength)};async function ao(e,t){const n=io[e],r=await k.get().subtle.importKey("raw",t,{name:"HMAC",hash:{name:n}},!1,["sign"]);return{async digest(s){return oo(r,s)},length:so[e]}}const co={"AES-128":{ivSize:16,keySize:16},"AES-256":{ivSize:16,keySize:32},Blowfish:{ivSize:8,keySize:32}};async function uo(e,t,n){if(e!=="AES-128"&&e!=="AES-256"&&e!=="Blowfish")throw new _("Cipher type was missing or unsupported");if(t!=="SHA1"&&t!=="SHA256"&&t!=="SHA512")throw new _("Hash type was missing or unsupported");if(n==null||!(n instanceof Uint8Array))throw new _("Secret was missing or an incorrect type");const r=co[e],s=r.keySize,i=r.ivSize,o=20,c=T("key expansion"),a=2*(i+s+o),m=await ao(t,n);let w=await m.digest(c);const b=[];let v=0;for(;v<a;){const l=await m.digest(wt([w,c]));let f=l.length;v+f>a&&(f=a-v),b.push(l),v+=f,w=await m.digest(w)}const N=a/2,d=wt(b),K=d.subarray(0,N),x=d.subarray(N,a),u=l=>({iv:l.subarray(0,i),cipherKey:l.subarray(i,i+s),macKey:l.subarray(i+s)});return{k1:u(K),k2:u(x)}}async function ho(e,t){if(e==="Ed25519")return ei();if(e==="secp256k1")return Zi();if(e==="RSA")return Ri(mo(t));if(e==="ECDSA")return Ls(Ao(t));throw new _t}async function fo(e,t){if(e!=="Ed25519")throw new _t("Seed key derivation only supported for Ed25519 keys");return ni(t)}function lo(e,t){const{Type:n,Data:r}=at.decode(e),s=r??new Uint8Array;switch(n){case U.RSA:return ki(s,t);case U.Ed25519:return ye(s);case U.secp256k1:return Se(s);case U.ECDSA:return fn(s);default:throw new _t}}function yo(e){if(e.byteLength===Kt)return ye(e);if(e.byteLength===ji)return Se(e);const t=ct(e),n=t[1]?.[0];if(n===rn||n===sn||n===on)return ln(t);if(t[0]?.[0]===Ni)return Cn(t,e);throw new _("Could not extract public key from raw bytes")}function bo(e){const{Type:t,Data:n}=at.decode(e.digest),r=n??new Uint8Array;switch(t){case U.Ed25519:return ye(r);case U.secp256k1:return Se(r);case U.ECDSA:return fn(r);default:throw new _t}}function Zt(e){return at.encode({Type:U[e.type],Data:e.raw})}function wo(e){const t=Vt.decode(e),n=t.Data??new Uint8Array;switch(t.Type){case U.RSA:return Ti(n);case U.Ed25519:return pn(n);case U.secp256k1:return Tn(n);case U.ECDSA:return Us(n);default:throw new _t}}function po(e){if(e.byteLength===Y)return pn(e);if(e.byteLength===Hi)return Tn(e);const t=ct(e),n=t[2]?.[0];if(n===rn||n===sn||n===on)return hn(t);if(t.length>8)return Un(t);throw new _("Could not extract private key from raw bytes")}function go(e){return Vt.encode({Type:U[e.type],Data:e.raw})}function mo(e){return e==null?2048:parseInt(e,10)}function Ao(e){if(e==="P-256"||e==null)return"P-256";if(e==="P-384")return"P-384";if(e==="P-521")return"P-521";throw new _("Unsupported curve, should be P-256, P-384 or P-521")}async function So(e){if(e.type==="RSA")return{privateKey:await crypto.subtle.importKey("jwk",e.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",e.publicKey.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])};if(e.type==="ECDSA")return{privateKey:await crypto.subtle.importKey("jwk",e.jwk,{name:"ECDSA",namedCurve:e.jwk.crv??"P-256"},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",e.publicKey.jwk,{name:"ECDSA",namedCurve:e.publicKey.jwk.crv??"P-256"},!0,["verify"])};throw new _("Only RSA and ECDSA keys are supported")}async function Eo(e){if(e.privateKey.algorithm.name==="RSASSA-PKCS1-v1_5"){const t=await crypto.subtle.exportKey("jwk",e.privateKey);return Dn(t)}if(e.privateKey.algorithm.name==="ECDSA"){const t=await crypto.subtle.exportKey("jwk",e.privateKey);return new xt(t)}throw new _("Only RSA and ECDSA keys are supported")}const Io=Object.freeze(Object.defineProperty({__proto__:null,generateEphemeralKeyPair:eo,generateKeyPair:ho,generateKeyPairFromSeed:fo,keyStretcher:uo,privateKeyFromCryptoKeyPair:Eo,privateKeyFromProtobuf:wo,privateKeyFromRaw:po,privateKeyToCryptoKeyPair:So,privateKeyToProtobuf:go,publicKeyFromMultihash:bo,publicKeyFromProtobuf:lo,publicKeyFromRaw:yo,publicKeyToProtobuf:Zt},Symbol.toStringTag,{value:"Module"}));export{L as C,vo as I,_t as U,Ko as a,H as b,_ as c,Pr as d,W as e,T as f,Et as g,es as h,fe as i,Bi as j,vn as k,xn as l,In as m,lo as n,wt as o,bo as p,Tt as q,Zt as r,tn as s,E as t,Io as u};
