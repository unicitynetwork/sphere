class V extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}}class cr extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}class ar extends Error{static name="InvalidPrivateKeyError";constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}}class Ya extends Error{static name="InvalidCIDError";constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}class Ga extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}class ue extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}function Bs(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function Te(e){if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}function _s(e){return new TextEncoder().encode(e)}function Is(e){return new TextDecoder().decode(e)}function Ls(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var s=0;s<e.length;s++){var i=e.charAt(s),o=i.charCodeAt(0);if(n[o]!==255)throw new TypeError(i+" is ambiguous");n[o]=s}var a=e.length,c=e.charAt(0),u=Math.log(a)/Math.log(256),y=Math.log(256)/Math.log(a);function f(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";for(var B=0,v=0,w=0,A=l.length;w!==A&&l[w]===0;)w++,B++;for(var g=(A-w)*y+1>>>0,_=new Uint8Array(g);w!==A;){for(var C=l[w],T=0,k=g-1;(C!==0||T<v)&&k!==-1;k--,T++)C+=256*_[k]>>>0,_[k]=C%a>>>0,C=C/a>>>0;if(C!==0)throw new Error("Non-zero carry");v=T,w++}for(var m=g-v;m!==g&&_[m]===0;)m++;for(var p=c.repeat(B);m<g;++m)p+=e.charAt(_[m]);return p}function x(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;var B=0;if(l[B]!==" "){for(var v=0,w=0;l[B]===c;)v++,B++;for(var A=(l.length-B)*u+1>>>0,g=new Uint8Array(A);l[B];){var _=n[l.charCodeAt(B)];if(_===255)return;for(var C=0,T=A-1;(_!==0||C<w)&&T!==-1;T--,C++)_+=a*g[T]>>>0,g[T]=_%256>>>0,_=_/256>>>0;if(_!==0)throw new Error("Non-zero carry");w=C,B++}if(l[B]!==" "){for(var k=A-w;k!==A&&g[k]===0;)k++;for(var m=new Uint8Array(v+(A-k)),p=v;k!==A;)m[p++]=g[k++];return m}}}function E(l){var B=x(l);if(B)return B;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:x,decode:E}}var Ks=Ls,Us=Ks;class Rs{name;prefix;baseEncode;constructor(t,n,r){this.name=t,this.prefix=n,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class Ds{name;prefix;baseDecode;prefixCodePoint;constructor(t,n,r){this.name=t,this.prefix=n;const s=n.codePointAt(0);if(s===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=s,this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return ur(this,t)}}class Cs{decoders;constructor(t){this.decoders=t}or(t){return ur(this,t)}decode(t){const n=t[0],r=this.decoders[n];if(r!=null)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function ur(e,t){return new Cs({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class Ns{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,n,r,s){this.name=t,this.prefix=n,this.baseEncode=r,this.baseDecode=s,this.encoder=new Rs(t,n,r),this.decoder=new Ds(t,n,s)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function ke({name:e,prefix:t,encode:n,decode:r}){return new Ns(e,t,n,r)}function fe({name:e,prefix:t,alphabet:n}){const{encode:r,decode:s}=Us(n,e);return ke({prefix:t,name:e,encode:r,decode:i=>Te(s(i))})}function Os(e,t,n,r){let s=e.length;for(;e[s-1]==="=";)--s;const i=new Uint8Array(s*n/8|0);let o=0,a=0,c=0;for(let u=0;u<s;++u){const y=t[e[u]];if(y===void 0)throw new SyntaxError(`Non-${r} character`);a=a<<n|y,o+=n,o>=8&&(o-=8,i[c++]=255&a>>o)}if(o>=n||(255&a<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return i}function Ts(e,t,n){const r=t[t.length-1]==="=",s=(1<<n)-1;let i="",o=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],o+=8;o>n;)o-=n,i+=t[s&a>>o];if(o!==0&&(i+=t[s&a<<n-o]),r)for(;(i.length*n&7)!==0;)i+="=";return i}function ks(e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=n;return t}function nt({name:e,prefix:t,bitsPerChar:n,alphabet:r}){const s=ks(r);return ke({prefix:t,name:e,encode(i){return Ts(i,r,n)},decode(i){return Os(i,s,n,e)}})}const ht=fe({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Ms=fe({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Hs=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ht,base58flickr:Ms},Symbol.toStringTag,{value:"Module"})),ee=nt({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),$s=nt({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ps=nt({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Vs=nt({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),qs=nt({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),zs=nt({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Fs=nt({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Zs=nt({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),js=nt({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Ys=Object.freeze(Object.defineProperty({__proto__:null,base32:ee,base32hex:qs,base32hexpad:Fs,base32hexpadupper:Zs,base32hexupper:zs,base32pad:Ps,base32padupper:Vs,base32upper:$s,base32z:js},Symbol.toStringTag,{value:"Module"})),Se=fe({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Gs=fe({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Xs=Object.freeze(Object.defineProperty({__proto__:null,base36:Se,base36upper:Gs},Symbol.toStringTag,{value:"Module"}));var Ws=fr,Nn=128,Js=-128,Qs=Math.pow(2,31);function fr(e,t,n){t=t||[],n=n||0;for(var r=n;e>=Qs;)t[n++]=e&255|Nn,e/=128;for(;e&Js;)t[n++]=e&255|Nn,e>>>=7;return t[n]=e|0,fr.bytes=n-r+1,t}var ti=en,ei=128,On=127;function en(e,r){var n=0,r=r||0,s=0,i=r,o,a=e.length;do{if(i>=a)throw en.bytes=0,new RangeError("Could not decode varint");o=e[i++],n+=s<28?(o&On)<<s:(o&On)*Math.pow(2,s),s+=7}while(o>=ei);return en.bytes=i-r,n}var ni=Math.pow(2,7),ri=Math.pow(2,14),si=Math.pow(2,21),ii=Math.pow(2,28),oi=Math.pow(2,35),ci=Math.pow(2,42),ai=Math.pow(2,49),ui=Math.pow(2,56),fi=Math.pow(2,63),hi=function(e){return e<ni?1:e<ri?2:e<si?3:e<ii?4:e<oi?5:e<ci?6:e<ai?7:e<ui?8:e<fi?9:10},li={encode:Ws,decode:ti,encodingLength:hi},_e=li;function nn(e,t=0){return[_e.decode(e,t),_e.decode.bytes]}function Ie(e,t,n=0){return _e.encode(e,t,n),t}function Le(e){return _e.encodingLength(e)}function Xt(e,t){const n=t.byteLength,r=Le(e),s=r+Le(n),i=new Uint8Array(s+n);return Ie(e,i,0),Ie(n,i,r),i.set(t,s),new dn(e,n,t,i)}function di(e){const t=Te(e),[n,r]=nn(t),[s,i]=nn(t.subarray(r)),o=t.subarray(r+i);if(o.byteLength!==s)throw new Error("Incorrect length");return new dn(n,s,o,t)}function bi(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&Bs(e.bytes,n.bytes)}}class dn{code;size;digest;bytes;constructor(t,n,r,s){this.code=t,this.size=n,this.digest=r,this.bytes=s}}function Tn(e,t){const{bytes:n,version:r}=e;return r===0?wi(n,rn(e),t??ht.encoder):gi(n,rn(e),t??ee.encoder)}const kn=new WeakMap;function rn(e){const t=kn.get(e);if(t==null){const n=new Map;return kn.set(e,n),n}return t}class G{code;version;multihash;bytes;"/";constructor(t,n,r,s){this.code=n,this.version=t,this.multihash=r,this.bytes=s,this["/"]=s}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:n}=this;if(t!==Wt)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(n.code!==pi)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return G.createV0(n)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:n}=this.multihash,r=Xt(t,n);return G.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return G.equals(this,t)}static equals(t,n){const r=n;return r!=null&&t.code===r.code&&t.version===r.version&&bi(t.multihash,r.multihash)}toString(t){return Tn(this,t)}toJSON(){return{"/":Tn(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const n=t;if(n instanceof G)return n;if(n["/"]!=null&&n["/"]===n.bytes||n.asCID===n){const{version:r,code:s,multihash:i,bytes:o}=n;return new G(r,s,i,o??Mn(r,s,i.bytes))}else if(n[mi]===!0){const{version:r,multihash:s,code:i}=n,o=di(s);return G.create(r,i,o)}else return null}static create(t,n,r){if(typeof n!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(n!==Wt)throw new Error(`Version 0 CID must use dag-pb (code: ${Wt}) block encoding`);return new G(t,n,r,r.bytes)}case 1:{const s=Mn(t,n,r.bytes);return new G(t,n,r,s)}default:throw new Error("Invalid version")}}static createV0(t){return G.create(0,Wt,t)}static createV1(t,n){return G.create(1,t,n)}static decode(t){const[n,r]=G.decodeFirst(t);if(r.length!==0)throw new Error("Incorrect length");return n}static decodeFirst(t){const n=G.inspectBytes(t),r=n.size-n.multihashSize,s=Te(t.subarray(r,r+n.multihashSize));if(s.byteLength!==n.multihashSize)throw new Error("Incorrect length");const i=s.subarray(n.multihashSize-n.digestSize),o=new dn(n.multihashCode,n.digestSize,i,s);return[n.version===0?G.createV0(o):G.createV1(n.codec,o),t.subarray(n.size)]}static inspectBytes(t){let n=0;const r=()=>{const[f,x]=nn(t.subarray(n));return n+=x,f};let s=r(),i=Wt;if(s===18?(s=0,n=0):i=r(),s!==0&&s!==1)throw new RangeError(`Invalid CID version ${s}`);const o=n,a=r(),c=r(),u=n+c,y=u-o;return{version:s,codec:i,multihashCode:a,digestSize:c,multihashSize:y,size:u}}static parse(t,n){const[r,s]=yi(t,n),i=G.decode(s);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return rn(i).set(r,t),i}}function yi(e,t){switch(e[0]){case"Q":{const n=t??ht;return[ht.prefix,n.decode(`${ht.prefix}${e}`)]}case ht.prefix:{const n=t??ht;return[ht.prefix,n.decode(e)]}case ee.prefix:{const n=t??ee;return[ee.prefix,n.decode(e)]}case Se.prefix:{const n=t??Se;return[Se.prefix,n.decode(e)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}}function wi(e,t,n){const{prefix:r}=n;if(r!==ht.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const s=t.get(r);if(s==null){const i=n.encode(e).slice(1);return t.set(r,i),i}else return s}function gi(e,t,n){const{prefix:r}=n,s=t.get(r);if(s==null){const i=n.encode(e);return t.set(r,i),i}else return s}const Wt=112,pi=18;function Mn(e,t,n){const r=Le(e),s=r+Le(t),i=new Uint8Array(s+n.byteLength);return Ie(e,i,0),Ie(t,i,r),i.set(n,s),i}const mi=Symbol.for("@ipld/js-cid/CID"),hr=0,xi="identity",lr=Te;function Ei(e,t){if(t?.truncate!=null&&t.truncate!==e.byteLength){if(t.truncate<0||t.truncate>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,t.truncate)}return Xt(hr,lr(e))}const bn={code:hr,name:xi,encode:lr,digest:Ei};function gt(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function St(e=0){return new Uint8Array(e)}function kt(e=0){return new Uint8Array(e)}function jt(e,t){t==null&&(t=e.reduce((s,i)=>s+i.length,0));const n=kt(t);let r=0;for(const s of e)n.set(s,r),r+=s.length;return n}const dr=Symbol.for("@achingbrain/uint8arraylist");function Hn(e,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let n=0;for(const r of e){const s=n+r.byteLength;if(t<s)return{buf:r,index:t-n};n=s}throw new RangeError("index is out of bounds")}function ye(e){return!!e?.[dr]}class at{bufs;length;[dr]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let n=0;for(const r of t)if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.push(r);else if(ye(r))n+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}prepend(...t){this.prependAll(t)}prependAll(t){let n=0;for(const r of t.reverse())if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.unshift(r);else if(ye(r))n+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}get(t){const n=Hn(this.bufs,t);return n.buf[n.index]}set(t,n){const r=Hn(this.bufs,t);r.buf[r.index]=n}write(t,n=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(n+r,t[r]);else if(ye(t))for(let r=0;r<t.length;r++)this.set(n+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,n){const{bufs:r,length:s}=this._subList(t,n);return jt(r,s)}subarray(t,n){const{bufs:r,length:s}=this._subList(t,n);return r.length===1?r[0]:jt(r,s)}sublist(t,n){const{bufs:r,length:s}=this._subList(t,n),i=new at;return i.length=s,i.bufs=[...r],i}_subList(t,n){if(t=t??0,n=n??this.length,t<0&&(t=this.length+t),n<0&&(n=this.length+n),t<0||n>this.length)throw new RangeError("index is out of bounds");if(t===n)return{bufs:[],length:0};if(t===0&&n===this.length)return{bufs:this.bufs,length:this.length};const r=[];let s=0;for(let i=0;i<this.bufs.length;i++){const o=this.bufs[i],a=s,c=a+o.byteLength;if(s=c,t>=c)continue;const u=t>=a&&t<c,y=n>a&&n<=c;if(u&&y){if(t===a&&n===c){r.push(o);break}const f=t-a;r.push(o.subarray(f,f+(n-t)));break}if(u){if(t===0){r.push(o);continue}r.push(o.subarray(t-a));continue}if(y){if(n===c){r.push(o);break}r.push(o.subarray(0,n-a));break}r.push(o)}return{bufs:r,length:n-t}}indexOf(t,n=0){if(!ye(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=t instanceof Uint8Array?t:t.subarray();if(n=Number(n??0),isNaN(n)&&(n=0),n<0&&(n=this.length+n),n<0&&(n=0),t.length===0)return n>this.length?this.length:n;const s=r.byteLength;if(s===0)throw new TypeError("search must be at least 1 byte long");const i=256,o=new Int32Array(i);for(let f=0;f<i;f++)o[f]=-1;for(let f=0;f<s;f++)o[r[f]]=f;const a=o,c=this.byteLength-r.byteLength,u=r.byteLength-1;let y;for(let f=n;f<=c;f+=y){y=0;for(let x=u;x>=0;x--){const E=this.get(f+x);if(r[x]!==E){y=Math.max(1,x-a[E]);break}}if(y===0)return f}return-1}getInt8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt8(0)}setInt8(t,n){const r=kt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,n),this.write(r,t)}getInt16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,n)}setInt16(t,n,r){const s=St(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt16(0,n,r),this.write(s,t)}getInt32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,n)}setInt32(t,n,r){const s=St(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setInt32(0,n,r),this.write(s,t)}getBigInt64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,n)}setBigInt64(t,n,r){const s=St(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigInt64(0,n,r),this.write(s,t)}getUint8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint8(0)}setUint8(t,n){const r=kt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,n),this.write(r,t)}getUint16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,n)}setUint16(t,n,r){const s=St(2);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint16(0,n,r),this.write(s,t)}getUint32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,n)}setUint32(t,n,r){const s=St(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setUint32(0,n,r),this.write(s,t)}getBigUint64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,n)}setBigUint64(t,n,r){const s=St(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setBigUint64(0,n,r),this.write(s,t)}getFloat32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,n)}setFloat32(t,n,r){const s=St(4);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat32(0,n,r),this.write(s,t)}getFloat64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,n)}setFloat64(t,n,r){const s=St(8);new DataView(s.buffer,s.byteOffset,s.byteLength).setFloat64(0,n,r),this.write(s,t)}equals(t){if(t==null||!(t instanceof at)||t.bufs.length!==this.bufs.length)return!1;for(let n=0;n<this.bufs.length;n++)if(!gt(this.bufs[n],t.bufs[n]))return!1;return!0}static fromUint8Arrays(t,n){const r=new at;return r.bufs=t,n==null&&(n=t.reduce((s,i)=>s+i.byteLength,0)),r.length=n,r}}const Ai=fe({prefix:"9",name:"base10",alphabet:"0123456789"}),Si=Object.freeze(Object.defineProperty({__proto__:null,base10:Ai},Symbol.toStringTag,{value:"Module"})),vi=nt({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Bi=nt({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),_i=Object.freeze(Object.defineProperty({__proto__:null,base16:vi,base16upper:Bi},Symbol.toStringTag,{value:"Module"})),Ii=nt({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Li=Object.freeze(Object.defineProperty({__proto__:null,base2:Ii},Symbol.toStringTag,{value:"Module"})),br=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Ki=br.reduce((e,t,n)=>(e[n]=t,e),[]),Ui=br.reduce((e,t,n)=>{const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);return e[r]=n,e},[]);function Ri(e){return e.reduce((t,n)=>(t+=Ki[n],t),"")}function Di(e){const t=[];for(const n of e){const r=n.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${n}`);const s=Ui[r];if(s==null)throw new Error(`Non-base256emoji character: ${n}`);t.push(s)}return new Uint8Array(t)}const Ci=ke({prefix:"ðŸš€",name:"base256emoji",encode:Ri,decode:Di}),Ni=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Ci},Symbol.toStringTag,{value:"Module"})),Oi=nt({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Ti=nt({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),ki=nt({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Mi=nt({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Hi=Object.freeze(Object.defineProperty({__proto__:null,base64:Oi,base64pad:Ti,base64url:ki,base64urlpad:Mi},Symbol.toStringTag,{value:"Module"})),$i=nt({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Pi=Object.freeze(Object.defineProperty({__proto__:null,base8:$i},Symbol.toStringTag,{value:"Module"})),Vi=ke({prefix:"\0",name:"identity",encode:e=>Is(e),decode:e=>_s(e)}),qi=Object.freeze(Object.defineProperty({__proto__:null,identity:Vi},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const zi=20;function Fi({name:e,code:t,encode:n,minDigestLength:r,maxDigestLength:s}){return new Zi(e,t,n,r,s)}class Zi{name;code;encode;minDigestLength;maxDigestLength;constructor(t,n,r,s,i){this.name=t,this.code=n,this.encode=r,this.minDigestLength=s??zi,this.maxDigestLength=i}digest(t,n){if(n?.truncate!=null){if(n.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&n.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const r=this.encode(t);return r instanceof Uint8Array?$n(r,this.code,n?.truncate):r.then(s=>$n(s,this.code,n?.truncate))}else throw Error("Unknown type, must be binary type")}}function $n(e,t,n){if(n!=null&&n!==e.byteLength){if(n>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,n)}return Xt(t,e)}function ji(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}const yr=Fi({name:"sha2-256",code:18,encode:ji("SHA-256")}),Pn={...qi,...Li,...Pi,...Si,..._i,...Ys,...Xs,...Hs,...Hi,...Ni};function wr(e,t,n,r){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:n},decoder:{decode:r}}}const Vn=wr("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>new TextEncoder().encode(e.substring(1))),Ze=wr("ascii","a",e=>{let t="a";for(let n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return t},e=>{e=e.substring(1);const t=kt(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}),gr={utf8:Vn,"utf-8":Vn,hex:Pn.base16,latin1:Ze,ascii:Ze,binary:Ze,...Pn};function W(e,t="utf8"){const n=gr[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.decoder.decode(`${n.prefix}${e}`)}function P(e,t="utf8"){const n=gr[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.encoder.encode(e).substring(1)}const Yi=parseInt("11111",2),sn=parseInt("10000000",2),Gi=parseInt("01111111",2),qn={0:Jt,1:Jt,2:Xi,3:Qi,4:to,5:Ji,6:Wi,16:Jt,22:Jt,48:Jt};function Ct(e,t={offset:0}){const n=e[t.offset]&Yi;if(t.offset++,qn[n]!=null)return qn[n](e,t);throw new Error("No decoder for tag "+n)}function he(e,t){let n=0;if((e[t.offset]&sn)===sn){const r=e[t.offset]&Gi;let s="0x";t.offset++;for(let i=0;i<r;i++,t.offset++)s+=e[t.offset].toString(16).padStart(2,"0");n=parseInt(s,16)}else n=e[t.offset],t.offset++;return n}function Jt(e,t){he(e,t);const n=[];for(;!(t.offset>=e.byteLength);){const r=Ct(e,t);if(r===null)break;n.push(r)}return n}function Xi(e,t){const n=he(e,t),r=t.offset,s=t.offset+n,i=[];for(let o=r;o<s;o++)o===r&&e[o]===0||i.push(e[o]);return t.offset+=n,Uint8Array.from(i)}function Wi(e,t){const n=he(e,t),r=t.offset+n,s=e[t.offset];t.offset++;let i=0,o=0;s<40?(i=0,o=s):s<80?(i=1,o=s-40):(i=2,o=s-80);let a=`${i}.${o}`,c=[];for(;t.offset<r;){const u=e[t.offset];if(t.offset++,c.push(u&127),u<128){c.reverse();let y=0;for(let f=0;f<c.length;f++)y+=c[f]<<f*7;a+=`.${y}`,c=[]}}return a}function Ji(e,t){return t.offset++,null}function Qi(e,t){const n=he(e,t),r=e[t.offset];t.offset++;const s=e.subarray(t.offset,t.offset+n-1);if(t.offset+=n,r!==0)throw new Error("Unused bits in bit string is unimplemented");return s}function to(e,t){const n=he(e,t),r=e.subarray(t.offset,t.offset+n);return t.offset+=n,r}function eo(e){let t=e.toString(16);t.length%2===1&&(t="0"+t);const n=new at;for(let r=0;r<t.length;r+=2)n.append(Uint8Array.from([parseInt(`${t[r]}${t[r+1]}`,16)]));return n}function Me(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=eo(e.byteLength);return new at(Uint8Array.from([t.byteLength|sn]),t)}function ft(e){const t=new at,n=128;return(e.subarray()[0]&n)===n&&t.append(Uint8Array.from([0])),t.append(e),new at(Uint8Array.from([2]),Me(t),t)}function yn(e){const t=Uint8Array.from([0]),n=new at(t,e);return new at(Uint8Array.from([3]),Me(n),n)}function no(e){return new at(Uint8Array.from([4]),Me(e),e)}function Et(e,t=48){const n=new at;for(const r of e)n.append(r);return new at(Uint8Array.from([t]),Me(n),n)}const pr="1.2.840.10045.3.1.7",mr="1.3.132.0.34",xr="1.3.132.0.35";async function ro(e="P-256"){const t=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:e},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",t.publicKey),privateKey:await crypto.subtle.exportKey("jwk",t.privateKey)}}async function so(e,t,n){const r=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["sign"]);n?.signal?.throwIfAborted();const s=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r,t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function io(e,t,n,r){const s=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);r?.signal?.throwIfAborted();const i=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},s,t,n.subarray());return r?.signal?.throwIfAborted(),i}const oo=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),co=Uint8Array.from([6,5,43,129,4,0,34]),ao=Uint8Array.from([6,5,43,129,4,0,35]),Er={ext:!0,kty:"EC",crv:"P-256"},Ar={ext:!0,kty:"EC",crv:"P-384"},Sr={ext:!0,kty:"EC",crv:"P-521"},Vt=32,qt=48,zt=66;function uo(e){const t=Ct(e);return vr(t)}function vr(e){const t=e[1],n=P(t,"base64url"),r=e[2][1][0],s=1;let i,o;if(t.byteLength===Vt)return i=P(r.subarray(s,s+Vt),"base64url"),o=P(r.subarray(s+Vt),"base64url"),new ne({...Er,key_ops:["sign"],d:n,x:i,y:o});if(t.byteLength===qt)return i=P(r.subarray(s,s+qt),"base64url"),o=P(r.subarray(s+qt),"base64url"),new ne({...Ar,key_ops:["sign"],d:n,x:i,y:o});if(t.byteLength===zt)return i=P(r.subarray(s,s+zt),"base64url"),o=P(r.subarray(s+zt),"base64url"),new ne({...Sr,key_ops:["sign"],d:n,x:i,y:o});throw new V(`Private key length was wrong length, got ${t.byteLength}, expected 32, 48 or 66`)}function Br(e){const t=Ct(e);return _r(t)}function _r(e){const t=e[1][1][0],n=1;let r,s;if(t.byteLength===Vt*2+1)return r=P(t.subarray(n,n+Vt),"base64url"),s=P(t.subarray(n+Vt),"base64url"),new ve({...Er,key_ops:["verify"],x:r,y:s});if(t.byteLength===qt*2+1)return r=P(t.subarray(n,n+qt),"base64url"),s=P(t.subarray(n+qt),"base64url"),new ve({...Ar,key_ops:["verify"],x:r,y:s});if(t.byteLength===zt*2+1)return r=P(t.subarray(n,n+zt),"base64url"),s=P(t.subarray(n+zt),"base64url"),new ve({...Sr,key_ops:["verify"],x:r,y:s});throw new V(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function fo(e){return Et([ft(Uint8Array.from([1])),no(W(e.d??"","base64url")),Et([Ir(e.crv)],160),Et([yn(new at(Uint8Array.from([4]),W(e.x??"","base64url"),W(e.y??"","base64url")))],161)]).subarray()}function ho(e){return Et([ft(Uint8Array.from([1])),Et([Ir(e.crv)],160),Et([yn(new at(Uint8Array.from([4]),W(e.x??"","base64url"),W(e.y??"","base64url")))],161)]).subarray()}function Ir(e){if(e==="P-256")return oo;if(e==="P-384")return co;if(e==="P-521")return ao;throw new V(`Invalid curve ${e}`)}async function lo(e="P-256"){const t=await ro(e);return new ne(t.privateKey)}class ve{type="ECDSA";jwk;_raw;constructor(t){this.jwk=t}get raw(){return this._raw==null&&(this._raw=ho(this.jwk)),this._raw}toMultihash(){return bn.digest(Fe(this))}toCID(){return G.createV1(114,this.toMultihash())}toString(){return ht.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}async verify(t,n,r){return io(this.jwk,n,t,r)}}class ne{type="ECDSA";jwk;publicKey;_raw;constructor(t){this.jwk=t,this.publicKey=new ve({crv:t.crv,ext:t.ext,key_ops:["verify"],kty:"EC",x:t.x,y:t.y})}get raw(){return this._raw==null&&(this._raw=fo(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}async sign(t,n){return so(this.jwk,t,n)}}function He(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function Mt(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function $(e,t,n=""){const r=He(e),s=e?.length,i=t!==void 0;if(!r||i&&s!==t){const o=n&&`"${n}" `,a=i?` of length ${t}`:"",c=r?`length=${s}`:`type=${typeof e}`;throw new Error(o+"expected Uint8Array"+a+", got "+c)}return e}function Lr(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash must wrapped by utils.createHasher");Mt(e.outputLen),Mt(e.blockLen)}function Ke(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function bo(e,t){$(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function Yt(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function je(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function bt(e,t){return e<<32-t|e>>>t}const Kr=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",yo=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function le(e){if($(e),Kr)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=yo[e[n]];return t}const pt={_0:48,_9:57,A:65,F:70,a:97,f:102};function zn(e){if(e>=pt._0&&e<=pt._9)return e-pt._0;if(e>=pt.A&&e<=pt.F)return e-(pt.A-10);if(e>=pt.a&&e<=pt.f)return e-(pt.a-10)}function se(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(Kr)return Uint8Array.fromHex(e);const t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(n);for(let s=0,i=0;s<n;s++,i+=2){const o=zn(e.charCodeAt(i)),a=zn(e.charCodeAt(i+1));if(o===void 0||a===void 0){const c=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}r[s]=o*16+a}return r}function wt(...e){let t=0;for(let r=0;r<e.length;r++){const s=e[r];$(s),t+=s.length}const n=new Uint8Array(t);for(let r=0,s=0;r<e.length;r++){const i=e[r];n.set(i,s),s+=i.length}return n}function Ur(e,t={}){const n=(s,i)=>e(i).update(s).digest(),r=e(void 0);return n.outputLen=r.outputLen,n.blockLen=r.blockLen,n.create=s=>e(s),Object.assign(n,t),Object.freeze(n)}function wn(e=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const Rr=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])});function wo(e,t,n){return e&t^~e&n}function go(e,t,n){return e&t^e&n^t&n}class Dr{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,n,r,s){this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(t),this.view=je(this.buffer)}update(t){Ke(this),$(t);const{view:n,buffer:r,blockLen:s}=this,i=t.length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a===s){const c=je(t);for(;s<=i-o;o+=s)this.process(c,o);continue}r.set(t.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ke(this),bo(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:i}=this;let{pos:o}=this;n[o++]=128,Yt(this.buffer.subarray(o)),this.padOffset>s-o&&(this.process(r,0),o=0);for(let f=o;f<s;f++)n[f]=0;r.setBigUint64(s-8,BigInt(this.length*8),i),this.process(r,0);const a=je(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen must be aligned to 32bit");const u=c/4,y=this.get();if(u>y.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<u;f++)a.setUint32(4*f,y[f],i)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||=new this.constructor,t.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:i,destroyed:o,pos:a}=this;return t.destroyed=o,t.finished=i,t.length=s,t.pos=a,s%n&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const vt=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),st=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),we=BigInt(2**32-1),Fn=BigInt(32);function po(e,t=!1){return t?{h:Number(e&we),l:Number(e>>Fn&we)}:{h:Number(e>>Fn&we)|0,l:Number(e&we)|0}}function mo(e,t=!1){const n=e.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let i=0;i<n;i++){const{h:o,l:a}=po(e[i],t);[r[i],s[i]]=[o,a]}return[r,s]}const Zn=(e,t,n)=>e>>>n,jn=(e,t,n)=>e<<32-n|t>>>n,$t=(e,t,n)=>e>>>n|t<<32-n,Pt=(e,t,n)=>e<<32-n|t>>>n,ge=(e,t,n)=>e<<64-n|t>>>n-32,pe=(e,t,n)=>e>>>n-32|t<<64-n;function mt(e,t,n,r){const s=(t>>>0)+(r>>>0);return{h:e+n+(s/2**32|0)|0,l:s|0}}const xo=(e,t,n)=>(e>>>0)+(t>>>0)+(n>>>0),Eo=(e,t,n,r)=>t+n+r+(e/2**32|0)|0,Ao=(e,t,n,r)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),So=(e,t,n,r,s)=>t+n+r+s+(e/2**32|0)|0,vo=(e,t,n,r,s)=>(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0)+(s>>>0),Bo=(e,t,n,r,s,i)=>t+n+r+s+i+(e/2**32|0)|0,_o=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Bt=new Uint32Array(64);class Io extends Dr{constructor(t){super(64,t,8,!1)}get(){const{A:t,B:n,C:r,D:s,E:i,F:o,G:a,H:c}=this;return[t,n,r,s,i,o,a,c]}set(t,n,r,s,i,o,a,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=i|0,this.F=o|0,this.G=a|0,this.H=c|0}process(t,n){for(let f=0;f<16;f++,n+=4)Bt[f]=t.getUint32(n,!1);for(let f=16;f<64;f++){const x=Bt[f-15],E=Bt[f-2],l=bt(x,7)^bt(x,18)^x>>>3,B=bt(E,17)^bt(E,19)^E>>>10;Bt[f]=B+Bt[f-7]+l+Bt[f-16]|0}let{A:r,B:s,C:i,D:o,E:a,F:c,G:u,H:y}=this;for(let f=0;f<64;f++){const x=bt(a,6)^bt(a,11)^bt(a,25),E=y+x+wo(a,c,u)+_o[f]+Bt[f]|0,B=(bt(r,2)^bt(r,13)^bt(r,22))+go(r,s,i)|0;y=u,u=c,c=a,a=o+E|0,o=i,i=s,s=r,r=E+B|0}r=r+this.A|0,s=s+this.B|0,i=i+this.C|0,o=o+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,y=y+this.H|0,this.set(r,s,i,o,a,c,u,y)}roundClean(){Yt(Bt)}destroy(){this.set(0,0,0,0,0,0,0,0),Yt(this.buffer)}}class Lo extends Io{A=vt[0]|0;B=vt[1]|0;C=vt[2]|0;D=vt[3]|0;E=vt[4]|0;F=vt[5]|0;G=vt[6]|0;H=vt[7]|0;constructor(){super(32)}}const Cr=mo(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(e=>BigInt(e))),Ko=Cr[0],Uo=Cr[1],_t=new Uint32Array(80),It=new Uint32Array(80);class Ro extends Dr{constructor(t){super(128,t,16,!1)}get(){const{Ah:t,Al:n,Bh:r,Bl:s,Ch:i,Cl:o,Dh:a,Dl:c,Eh:u,El:y,Fh:f,Fl:x,Gh:E,Gl:l,Hh:B,Hl:v}=this;return[t,n,r,s,i,o,a,c,u,y,f,x,E,l,B,v]}set(t,n,r,s,i,o,a,c,u,y,f,x,E,l,B,v){this.Ah=t|0,this.Al=n|0,this.Bh=r|0,this.Bl=s|0,this.Ch=i|0,this.Cl=o|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=y|0,this.Fh=f|0,this.Fl=x|0,this.Gh=E|0,this.Gl=l|0,this.Hh=B|0,this.Hl=v|0}process(t,n){for(let g=0;g<16;g++,n+=4)_t[g]=t.getUint32(n),It[g]=t.getUint32(n+=4);for(let g=16;g<80;g++){const _=_t[g-15]|0,C=It[g-15]|0,T=$t(_,C,1)^$t(_,C,8)^Zn(_,C,7),k=Pt(_,C,1)^Pt(_,C,8)^jn(_,C,7),m=_t[g-2]|0,p=It[g-2]|0,N=$t(m,p,19)^ge(m,p,61)^Zn(m,p,6),M=Pt(m,p,19)^pe(m,p,61)^jn(m,p,6),U=Ao(k,M,It[g-7],It[g-16]),d=So(U,T,N,_t[g-7],_t[g-16]);_t[g]=d|0,It[g]=U|0}let{Ah:r,Al:s,Bh:i,Bl:o,Ch:a,Cl:c,Dh:u,Dl:y,Eh:f,El:x,Fh:E,Fl:l,Gh:B,Gl:v,Hh:w,Hl:A}=this;for(let g=0;g<80;g++){const _=$t(f,x,14)^$t(f,x,18)^ge(f,x,41),C=Pt(f,x,14)^Pt(f,x,18)^pe(f,x,41),T=f&E^~f&B,k=x&l^~x&v,m=vo(A,C,k,Uo[g],It[g]),p=Bo(m,w,_,T,Ko[g],_t[g]),N=m|0,M=$t(r,s,28)^ge(r,s,34)^ge(r,s,39),U=Pt(r,s,28)^pe(r,s,34)^pe(r,s,39),d=r&i^r&a^i&a,b=s&o^s&c^o&c;w=B|0,A=v|0,B=E|0,v=l|0,E=f|0,l=x|0,{h:f,l:x}=mt(u|0,y|0,p|0,N|0),u=a|0,y=c|0,a=i|0,c=o|0,i=r|0,o=s|0;const h=xo(N,U,b);r=Eo(h,p,M,d),s=h|0}({h:r,l:s}=mt(this.Ah|0,this.Al|0,r|0,s|0)),{h:i,l:o}=mt(this.Bh|0,this.Bl|0,i|0,o|0),{h:a,l:c}=mt(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l:y}=mt(this.Dh|0,this.Dl|0,u|0,y|0),{h:f,l:x}=mt(this.Eh|0,this.El|0,f|0,x|0),{h:E,l}=mt(this.Fh|0,this.Fl|0,E|0,l|0),{h:B,l:v}=mt(this.Gh|0,this.Gl|0,B|0,v|0),{h:w,l:A}=mt(this.Hh|0,this.Hl|0,w|0,A|0),this.set(r,s,i,o,a,c,u,y,f,x,E,l,B,v,w,A)}roundClean(){Yt(_t,It)}destroy(){Yt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Do extends Ro{Ah=st[0]|0;Al=st[1]|0;Bh=st[2]|0;Bl=st[3]|0;Ch=st[4]|0;Cl=st[5]|0;Dh=st[6]|0;Dl=st[7]|0;Eh=st[8]|0;El=st[9]|0;Fh=st[10]|0;Fl=st[11]|0;Gh=st[12]|0;Gl=st[13]|0;Hh=st[14]|0;Hl=st[15]|0;constructor(){super(64)}}const $e=Ur(()=>new Lo,Rr(1)),Co=Ur(()=>new Do,Rr(3));const gn=BigInt(0),on=BigInt(1);function Ht(e,t=""){if(typeof e!="boolean"){const n=t&&`"${t}" `;throw new Error(n+"expected boolean, got type="+typeof e)}return e}function Nr(e){if(typeof e=="bigint"){if(!Be(e))throw new Error("positive bigint expected, got "+e)}else Mt(e);return e}function me(e){const t=Nr(e).toString(16);return t.length&1?"0"+t:t}function Or(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?gn:BigInt("0x"+e)}function Pe(e){return Or(le(e))}function ie(e){return Or(le(cn($(e)).reverse()))}function pn(e,t){Mt(t),e=Nr(e);const n=se(e.toString(16).padStart(t*2,"0"));if(n.length!==t)throw new Error("number too large");return n}function Tr(e,t){return pn(e,t).reverse()}function cn(e){return Uint8Array.from(e)}const Be=e=>typeof e=="bigint"&&gn<=e;function No(e,t,n){return Be(e)&&Be(t)&&Be(n)&&t<=e&&e<n}function an(e,t,n,r){if(!No(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function Oo(e){let t;for(t=0;e>gn;e>>=on,t+=1);return t}const mn=e=>(on<<BigInt(e))-on;function To(e,t,n){if(Mt(e,"hashLen"),Mt(t,"qByteLen"),typeof n!="function")throw new Error("hmacFn must be a function");const r=v=>new Uint8Array(v),s=Uint8Array.of(),i=Uint8Array.of(0),o=Uint8Array.of(1),a=1e3;let c=r(e),u=r(e),y=0;const f=()=>{c.fill(1),u.fill(0),y=0},x=(...v)=>n(u,wt(c,...v)),E=(v=s)=>{u=x(i,v),c=x(),v.length!==0&&(u=x(o,v),c=x())},l=()=>{if(y++>=a)throw new Error("drbg: tried max amount of iterations");let v=0;const w=[];for(;v<t;){c=x();const A=c.slice();w.push(A),v+=c.length}return wt(...w)};return(v,w)=>{f(),E(v);let A;for(;!(A=w(l()));)E();return f(),A}}function de(e,t={},n={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(i,o,a){const c=e[i];if(a&&c===void 0)return;const u=typeof c;if(u!==o||c===null)throw new Error(`param "${i}" is invalid: expected ${o}, got ${u}`)}const s=(i,o)=>Object.entries(i).forEach(([a,c])=>r(a,c,o));s(t,!1),s(n,!0)}function Ue(e){const t=new WeakMap;return(n,...r)=>{const s=t.get(n);if(s!==void 0)return s;const i=e(n,...r);return t.set(n,i),i}}const ut=BigInt(0),et=BigInt(1),Nt=BigInt(2),kr=BigInt(3),Mr=BigInt(4),Hr=BigInt(5),ko=BigInt(7),$r=BigInt(8),Mo=BigInt(9),Pr=BigInt(16);function X(e,t){const n=e%t;return n>=ut?n:t+n}function Y(e,t,n){let r=e;for(;t-- >ut;)r*=r,r%=n;return r}function Yn(e,t){if(e===ut)throw new Error("invert: expected non-zero number");if(t<=ut)throw new Error("invert: expected positive modulus, got "+t);let n=X(e,t),r=t,s=ut,i=et;for(;n!==ut;){const a=r/n,c=r%n,u=s-i*a;r=n,n=c,s=i,i=u}if(r!==et)throw new Error("invert: does not exist");return X(s,t)}function xn(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function Vr(e,t){const n=(e.ORDER+et)/Mr,r=e.pow(t,n);return xn(e,r,t),r}function Ho(e,t){const n=(e.ORDER-Hr)/$r,r=e.mul(t,Nt),s=e.pow(r,n),i=e.mul(t,s),o=e.mul(e.mul(i,Nt),s),a=e.mul(i,e.sub(o,e.ONE));return xn(e,a,t),a}function $o(e){const t=Ve(e),n=qr(e),r=n(t,t.neg(t.ONE)),s=n(t,r),i=n(t,t.neg(r)),o=(e+ko)/Pr;return(a,c)=>{let u=a.pow(c,o),y=a.mul(u,r);const f=a.mul(u,s),x=a.mul(u,i),E=a.eql(a.sqr(y),c),l=a.eql(a.sqr(f),c);u=a.cmov(u,y,E),y=a.cmov(x,f,l);const B=a.eql(a.sqr(y),c),v=a.cmov(u,y,B);return xn(a,v,c),v}}function qr(e){if(e<kr)throw new Error("sqrt is not defined for small field");let t=e-et,n=0;for(;t%Nt===ut;)t/=Nt,n++;let r=Nt;const s=Ve(e);for(;Gn(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return Vr;let i=s.pow(r,t);const o=(t+et)/Nt;return function(c,u){if(c.is0(u))return u;if(Gn(c,u)!==1)throw new Error("Cannot find square root");let y=n,f=c.mul(c.ONE,i),x=c.pow(u,t),E=c.pow(u,o);for(;!c.eql(x,c.ONE);){if(c.is0(x))return c.ZERO;let l=1,B=c.sqr(x);for(;!c.eql(B,c.ONE);)if(l++,B=c.sqr(B),l===y)throw new Error("Cannot find square root");const v=et<<BigInt(y-l-1),w=c.pow(f,v);y=l,f=c.sqr(w),x=c.mul(x,f),E=c.mul(E,w)}return E}}function Po(e){return e%Mr===kr?Vr:e%$r===Hr?Ho:e%Pr===Mo?$o(e):qr(e)}const Vo=(e,t)=>(X(e,t)&et)===et,qo=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function zo(e){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},n=qo.reduce((r,s)=>(r[s]="function",r),t);return de(e,n),e}function Fo(e,t,n){if(n<ut)throw new Error("invalid exponent, negatives unsupported");if(n===ut)return e.ONE;if(n===et)return t;let r=e.ONE,s=t;for(;n>ut;)n&et&&(r=e.mul(r,s)),s=e.sqr(s),n>>=et;return r}function zr(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),s=t.reduce((o,a,c)=>e.is0(a)?o:(r[c]=o,e.mul(o,a)),e.ONE),i=e.inv(s);return t.reduceRight((o,a,c)=>e.is0(a)?o:(r[c]=e.mul(o,r[c]),e.mul(o,a)),i),r}function Gn(e,t){const n=(e.ORDER-et)/Nt,r=e.pow(t,n),s=e.eql(r,e.ONE),i=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Zo(e,t){t!==void 0&&Mt(t);const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}class jo{ORDER;BITS;BYTES;isLE;ZERO=ut;ONE=et;_lengths;_sqrt;_mod;constructor(t,n={}){if(t<=ut)throw new Error("invalid field: expected ORDER > 0, got "+t);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));const{nBitLength:s,nByteLength:i}=Zo(t,r);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=i,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return X(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return ut<=t&&t<this.ORDER}is0(t){return t===ut}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&et)===et}neg(t){return X(-t,this.ORDER)}eql(t,n){return t===n}sqr(t){return X(t*t,this.ORDER)}add(t,n){return X(t+n,this.ORDER)}sub(t,n){return X(t-n,this.ORDER)}mul(t,n){return X(t*n,this.ORDER)}pow(t,n){return Fo(this,t,n)}div(t,n){return X(t*Yn(n,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,n){return t+n}subN(t,n){return t-n}mulN(t,n){return t*n}inv(t){return Yn(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Po(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Tr(t,this.BYTES):pn(t,this.BYTES)}fromBytes(t,n=!1){$(t);const{_lengths:r,BYTES:s,isLE:i,ORDER:o,_mod:a}=this;if(r){if(!r.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);const u=new Uint8Array(s);u.set(t,i?0:u.length-t.length),t=u}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let c=i?ie(t):Pe(t);if(a&&(c=X(c,o)),!n&&!this.isValid(c))throw new Error("invalid field element: outside of range 0..ORDER");return c}invertBatch(t){return zr(this,t)}cmov(t,n,r){return r?n:t}}function Ve(e,t={}){return new jo(e,t)}function Fr(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Zr(e){const t=Fr(e);return t+Math.ceil(t/2)}function Yo(e,t,n=!1){$(e);const r=e.length,s=Fr(t),i=Zr(t);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=n?ie(e):Pe(e),a=X(o,t-et)+et;return n?Tr(a,s):pn(a,s)}const Gt=BigInt(0),Ot=BigInt(1);function Re(e,t){const n=t.negate();return e?n:t}function re(e,t){const n=zr(e.Fp,t.map(r=>r.Z));return t.map((r,s)=>e.fromAffine(r.toAffine(n[s])))}function jr(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function Ye(e,t){jr(e,t);const n=Math.ceil(t/e)+1,r=2**(e-1),s=2**e,i=mn(e),o=BigInt(e);return{windows:n,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function Xn(e,t,n){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=n;let a=Number(e&s),c=e>>o;a>r&&(a-=i,c+=Ot);const u=t*r,y=u+Math.abs(a)-1,f=a===0,x=a<0,E=t%2!==0;return{nextN:c,offset:y,isZero:f,isNeg:x,isNegF:E,offsetF:u}}const Ge=new WeakMap,Yr=new WeakMap;function Xe(e){return Yr.get(e)||1}function Wn(e){if(e!==Gt)throw new Error("invalid wNAF")}class Gr{BASE;ZERO;Fn;bits;constructor(t,n){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let s=t;for(;n>Gt;)n&Ot&&(r=r.add(s)),s=s.double(),n>>=Ot;return r}precomputeWindow(t,n){const{windows:r,windowSize:s}=Ye(n,this.bits),i=[];let o=t,a=o;for(let c=0;c<r;c++){a=o,i.push(a);for(let u=1;u<s;u++)a=a.add(o),i.push(a);o=a.double()}return i}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,i=this.BASE;const o=Ye(t,this.bits);for(let a=0;a<o.windows;a++){const{nextN:c,offset:u,isZero:y,isNeg:f,isNegF:x,offsetF:E}=Xn(r,a,o);r=c,y?i=i.add(Re(x,n[E])):s=s.add(Re(f,n[u]))}return Wn(r),{p:s,f:i}}wNAFUnsafe(t,n,r,s=this.ZERO){const i=Ye(t,this.bits);for(let o=0;o<i.windows&&r!==Gt;o++){const{nextN:a,offset:c,isZero:u,isNeg:y}=Xn(r,o,i);if(r=a,!u){const f=n[c];s=s.add(y?f.negate():f)}}return Wn(r),s}getPrecomputes(t,n,r){let s=Ge.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(s=r(s)),Ge.set(n,s))),s}cached(t,n,r){const s=Xe(t);return this.wNAF(s,this.getPrecomputes(s,t,r),n)}unsafe(t,n,r,s){const i=Xe(t);return i===1?this._unsafeLadder(t,n,s):this.wNAFUnsafe(i,this.getPrecomputes(i,t,r),n,s)}createCache(t,n){jr(n,this.bits),Yr.set(t,n),Ge.delete(t)}hasCache(t){return Xe(t)!==1}}function Go(e,t,n,r){let s=t,i=e.ZERO,o=e.ZERO;for(;n>Gt||r>Gt;)n&Ot&&(i=i.add(s)),r&Ot&&(o=o.add(s)),s=s.double(),n>>=Ot,r>>=Ot;return{p1:i,p2:o}}function Jn(e,t,n){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return zo(t),t}else return Ve(e,{isLE:n})}function Xr(e,t,n={},r){if(r===void 0&&(r=e==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${e} CURVE object`);for(const c of["p","n","h"]){const u=t[c];if(!(typeof u=="bigint"&&u>Gt))throw new Error(`CURVE.${c} must be positive bigint`)}const s=Jn(t.p,n.Fp,r),i=Jn(t.n,n.Fn,r),a=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const c of a)if(!s.isValid(t[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:s,Fn:i}}function Wr(e,t){return function(r){const s=e(r);return{secretKey:s,publicKey:t(s)}}}const Lt=BigInt(0),Q=BigInt(1),We=BigInt(2),Xo=BigInt(8);function Wo(e,t,n,r){const s=e.sqr(n),i=e.sqr(r),o=e.add(e.mul(t.a,s),i),a=e.add(e.ONE,e.mul(t.d,e.mul(s,i)));return e.eql(o,a)}function Jo(e,t={}){const n=Xr("edwards",e,t,t.FpFnLE),{Fp:r,Fn:s}=n;let i=n.CURVE;const{h:o}=i;de(t,{},{uvRatio:"function"});const a=We<<BigInt(s.BYTES*8)-Q,c=v=>r.create(v),u=t.uvRatio||((v,w)=>{try{return{isValid:!0,value:r.sqrt(r.div(v,w))}}catch{return{isValid:!1,value:Lt}}});if(!Wo(r,i,i.Gx,i.Gy))throw new Error("bad curve params: generator point");function y(v,w,A=!1){const g=A?Q:Lt;return an("coordinate "+v,w,g,a),w}function f(v){if(!(v instanceof l))throw new Error("EdwardsPoint expected")}const x=Ue((v,w)=>{const{X:A,Y:g,Z:_}=v,C=v.is0();w==null&&(w=C?Xo:r.inv(_));const T=c(A*w),k=c(g*w),m=r.mul(_,w);if(C)return{x:Lt,y:Q};if(m!==Q)throw new Error("invZ was invalid");return{x:T,y:k}}),E=Ue(v=>{const{a:w,d:A}=i;if(v.is0())throw new Error("bad point: ZERO");const{X:g,Y:_,Z:C,T}=v,k=c(g*g),m=c(_*_),p=c(C*C),N=c(p*p),M=c(k*w),U=c(p*c(M+m)),d=c(N+c(A*c(k*m)));if(U!==d)throw new Error("bad point: equation left != right (1)");const b=c(g*_),h=c(C*T);if(b!==h)throw new Error("bad point: equation left != right (2)");return!0});class l{static BASE=new l(i.Gx,i.Gy,Q,c(i.Gx*i.Gy));static ZERO=new l(Lt,Q,Q,Lt);static Fp=r;static Fn=s;X;Y;Z;T;constructor(w,A,g,_){this.X=y("x",w),this.Y=y("y",A),this.Z=y("z",g,!0),this.T=y("t",_),Object.freeze(this)}static CURVE(){return i}static fromAffine(w){if(w instanceof l)throw new Error("extended point not allowed");const{x:A,y:g}=w||{};return y("x",A),y("y",g),new l(A,g,Q,c(A*g))}static fromBytes(w,A=!1){const g=r.BYTES,{a:_,d:C}=i;w=cn($(w,g,"point")),Ht(A,"zip215");const T=cn(w),k=w[g-1];T[g-1]=k&-129;const m=ie(T),p=A?a:r.ORDER;an("point.y",m,Lt,p);const N=c(m*m),M=c(N-Q),U=c(C*N-_);let{isValid:d,value:b}=u(M,U);if(!d)throw new Error("bad point: invalid y coordinate");const h=(b&Q)===Q,S=(k&128)!==0;if(!A&&b===Lt&&S)throw new Error("bad point: x=0 and x_0=1");return S!==h&&(b=c(-b)),l.fromAffine({x:b,y:m})}static fromHex(w,A=!1){return l.fromBytes(se(w),A)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(w=8,A=!0){return B.createCache(this,w),A||this.multiply(We),this}assertValidity(){E(this)}equals(w){f(w);const{X:A,Y:g,Z:_}=this,{X:C,Y:T,Z:k}=w,m=c(A*k),p=c(C*_),N=c(g*k),M=c(T*_);return m===p&&N===M}is0(){return this.equals(l.ZERO)}negate(){return new l(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:w}=i,{X:A,Y:g,Z:_}=this,C=c(A*A),T=c(g*g),k=c(We*c(_*_)),m=c(w*C),p=A+g,N=c(c(p*p)-C-T),M=m+T,U=M-k,d=m-T,b=c(N*U),h=c(M*d),S=c(N*d),I=c(U*M);return new l(b,h,I,S)}add(w){f(w);const{a:A,d:g}=i,{X:_,Y:C,Z:T,T:k}=this,{X:m,Y:p,Z:N,T:M}=w,U=c(_*m),d=c(C*p),b=c(k*g*M),h=c(T*N),S=c((_+C)*(m+p)-U-d),I=h-b,K=h+b,R=c(d-A*U),L=c(S*I),D=c(K*R),O=c(S*R),F=c(I*K);return new l(L,D,F,O)}subtract(w){return this.add(w.negate())}multiply(w){if(!s.isValidNot0(w))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:A,f:g}=B.cached(this,w,_=>re(l,_));return re(l,[A,g])[0]}multiplyUnsafe(w,A=l.ZERO){if(!s.isValid(w))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return w===Lt?l.ZERO:this.is0()||w===Q?this:B.unsafe(this,w,g=>re(l,g),A)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return B.unsafe(this,i.n).is0()}toAffine(w){return x(this,w)}clearCofactor(){return o===Q?this:this.multiplyUnsafe(o)}toBytes(){const{x:w,y:A}=this.toAffine(),g=r.toBytes(A);return g[g.length-1]|=w&Q?128:0,g}toHex(){return le(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const B=new Gr(l,s.BITS);return l.BASE.precompute(8),l}function Qo(e,t,n={}){if(typeof t!="function")throw new Error('"hash" function param is required');de(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:s,Fp:i,Fn:o}=e,a=n.randomBytes||wn,c=n.adjustScalarBytes||(m=>m),u=n.domain||((m,p,N)=>{if(Ht(N,"phflag"),p.length||N)throw new Error("Contexts/pre-hash are not supported");return m});function y(m){return o.create(ie(m))}function f(m){const p=g.secretKey;$(m,g.secretKey,"secretKey");const N=$(t(m),2*p,"hashedSecretKey"),M=c(N.slice(0,p)),U=N.slice(p,2*p),d=y(M);return{head:M,prefix:U,scalar:d}}function x(m){const{head:p,prefix:N,scalar:M}=f(m),U=s.multiply(M),d=U.toBytes();return{head:p,prefix:N,scalar:M,point:U,pointBytes:d}}function E(m){return x(m).pointBytes}function l(m=Uint8Array.of(),...p){const N=wt(...p);return y(t(u(N,$(m,void 0,"context"),!!r)))}function B(m,p,N={}){m=$(m,void 0,"message"),r&&(m=r(m));const{prefix:M,scalar:U,pointBytes:d}=x(p),b=l(N.context,M,m),h=s.multiply(b).toBytes(),S=l(N.context,h,d,m),I=o.create(b+S*U);if(!o.isValid(I))throw new Error("sign failed: invalid s");const K=wt(h,o.toBytes(I));return $(K,g.signature,"result")}const v={zip215:!0};function w(m,p,N,M=v){const{context:U,zip215:d}=M,b=g.signature;m=$(m,b,"signature"),p=$(p,void 0,"message"),N=$(N,g.publicKey,"publicKey"),d!==void 0&&Ht(d,"zip215"),r&&(p=r(p));const h=b/2,S=m.subarray(0,h),I=ie(m.subarray(h,b));let K,R,L;try{K=e.fromBytes(N,d),R=e.fromBytes(S,d),L=s.multiplyUnsafe(I)}catch{return!1}if(!d&&K.isSmallOrder())return!1;const D=l(U,R.toBytes(),K.toBytes(),p);return R.add(K.multiplyUnsafe(D)).subtract(L).clearCofactor().is0()}const A=i.BYTES,g={secretKey:A,publicKey:A,signature:2*A,seed:A};function _(m=a(g.seed)){return $(m,g.seed,"seed")}function C(m){return He(m)&&m.length===o.BYTES}function T(m,p){try{return!!e.fromBytes(m,p)}catch{return!1}}const k={getExtendedPublicKey:x,randomSecretKey:_,isValidSecretKey:C,isValidPublicKey:T,toMontgomery(m){const{y:p}=e.fromBytes(m),N=g.publicKey,M=N===32;if(!M&&N!==57)throw new Error("only defined for 25519 and 448");const U=M?i.div(Q+p,Q-p):i.div(p-Q,p+Q);return i.toBytes(U)},toMontgomerySecret(m){const p=g.secretKey;$(m,p);const N=t(m.subarray(0,p));return c(N).subarray(0,p)}};return Object.freeze({keygen:Wr(_,E),getPublicKey:E,sign:B,verify:w,utils:k,Point:e,lengths:g})}const tc=BigInt(1),Qn=BigInt(2),ec=BigInt(5),nc=BigInt(8),En=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),rc={p:En,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:nc,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function sc(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),s=BigInt(80),i=En,a=e*e%i*e%i,c=Y(a,Qn,i)*a%i,u=Y(c,tc,i)*e%i,y=Y(u,ec,i)*u%i,f=Y(y,t,i)*y%i,x=Y(f,n,i)*f%i,E=Y(x,r,i)*x%i,l=Y(E,s,i)*E%i,B=Y(l,s,i)*E%i,v=Y(B,t,i)*y%i;return{pow_p_5_8:Y(v,Qn,i)*e%i,b2:a}}function ic(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const tr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function oc(e,t){const n=En,r=X(t*t*t,n),s=X(r*r*t,n),i=sc(e*s).pow_p_5_8;let o=X(e*r*i,n);const a=X(t*o*o,n),c=o,u=X(o*tr,n),y=a===e,f=a===X(-e,n),x=a===X(-e*tr,n);return y&&(o=c),(f||x)&&(o=u),Vo(o,n)&&(o=X(-o,n)),{isValid:y||f,value:o}}const cc=Jo(rc,{uvRatio:oc});function ac(e){return Qo(cc,Co,Object.assign({adjustScalarBytes:ic},e))}const oe=ac({});class er extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}}class nr extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class uc extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const J={get(e=globalThis){const t=e.crypto;if(t?.subtle==null)throw new uc("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},ce=32,yt=64,De=32;let Ft;const Jr=(async()=>{try{return await J.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function fc(){const e=oe.utils.randomSecretKey(),t=oe.getPublicKey(e);return{privateKey:Qr(e,t),publicKey:t}}function hc(e){if(e.length!==De)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=oe.getPublicKey(t);return{privateKey:Qr(t,n),publicKey:n}}async function lc(e,t){let n;e.length===yt?n=e.subarray(0,32):n=e;const r={crv:"Ed25519",kty:"OKP",x:P(e.subarray(32),"base64url"),d:P(n,"base64url"),ext:!0,key_ops:["sign"]},s=await J.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),i=await J.get().subtle.sign({name:"Ed25519"},s,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(i,0,i.byteLength)}function dc(e,t){const n=e.subarray(0,De);return oe.sign(t instanceof Uint8Array?t:t.subarray(),n)}async function bc(e,t){return Ft==null&&(Ft=await Jr),Ft?lc(e,t):dc(e,t)}async function yc(e,t,n){if(e.buffer instanceof ArrayBuffer){const r=await J.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await J.get().subtle.verify({name:"Ed25519"},r,t,n instanceof Uint8Array?n:n.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function wc(e,t,n){return oe.verify(t,n instanceof Uint8Array?n:n.subarray(),e)}async function gc(e,t,n){return Ft==null&&(Ft=await Jr),Ft?yc(e,t,n):wc(e,t,n)}function Qr(e,t){const n=new Uint8Array(yt);for(let r=0;r<De;r++)n[r]=e[r],n[De+r]=t[r];return n}function rr(e,t){let n=W(e,"base64urlpad");if(t!=null){if(n.length>t)throw new Error("byte array longer than desired length");n=jt([new Uint8Array(t-n.length),n])}return n}function qe(e){return e==null?!1:typeof e.then=="function"&&typeof e.catch=="function"&&typeof e.finally=="function"}class ts{type="Ed25519";raw;constructor(t){this.raw=ae(t,ce)}toMultihash(){return bn.digest(Fe(this))}toCID(){return G.createV1(114,this.toMultihash())}toString(){return ht.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}verify(t,n,r){r?.signal?.throwIfAborted();const s=gc(this.raw,n,t);return qe(s)?s.then(i=>(r?.signal?.throwIfAborted(),i)):s}}class Ce{type="Ed25519";raw;publicKey;constructor(t,n){this.raw=ae(t,yt),this.publicKey=new ts(n)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}sign(t,n){n?.signal?.throwIfAborted();const r=bc(this.raw,t);return qe(r)?r.then(s=>(n?.signal?.throwIfAborted(),s)):(n?.signal?.throwIfAborted(),r)}}function es(e){if(e.length>yt){e=ae(e,yt+ce);const r=e.subarray(0,yt),s=e.subarray(yt,e.length);return new Ce(r,s)}e=ae(e,yt);const t=e.subarray(0,yt),n=e.subarray(ce);return new Ce(t,n)}function An(e){return e=ae(e,ce),new ts(e)}async function pc(){const{privateKey:e,publicKey:t}=fc();return new Ce(e,t)}async function mc(e){const{privateKey:t,publicKey:n}=hc(e);return new Ce(t,n)}function ae(e,t){if(e=Uint8Array.from(e??[]),e.length!==t)throw new V(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}const xc=Math.pow(2,7),Ec=Math.pow(2,14),Ac=Math.pow(2,21),ns=Math.pow(2,28),rs=Math.pow(2,35),ss=Math.pow(2,42),is=Math.pow(2,49),ct=128,Kt=127;function Sn(e){if(e<xc)return 1;if(e<Ec)return 2;if(e<Ac)return 3;if(e<ns)return 4;if(e<rs)return 5;if(e<ss)return 6;if(e<is)return 7;if(Number.MAX_SAFE_INTEGER!=null&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Sc(e,t,n=0){switch(Sn(e)){case 8:t[n++]=e&255|ct,e/=128;case 7:t[n++]=e&255|ct,e/=128;case 6:t[n++]=e&255|ct,e/=128;case 5:t[n++]=e&255|ct,e/=128;case 4:t[n++]=e&255|ct,e>>>=7;case 3:t[n++]=e&255|ct,e>>>=7;case 2:t[n++]=e&255|ct,e>>>=7;case 1:{t[n++]=e&255,e>>>=7;break}default:throw new Error("unreachable")}return t}function vc(e,t){let n=e[t],r=0;if(r+=n&Kt,n<ct||(n=e[t+1],r+=(n&Kt)<<7,n<ct)||(n=e[t+2],r+=(n&Kt)<<14,n<ct)||(n=e[t+3],r+=(n&Kt)<<21,n<ct)||(n=e[t+4],r+=(n&Kt)*ns,n<ct)||(n=e[t+5],r+=(n&Kt)*rs,n<ct)||(n=e[t+6],r+=(n&Kt)*ss,n<ct)||(n=e[t+7],r+=(n&Kt)*is,n<ct))return r;throw new RangeError("Could not decode varint")}const vn=new Float32Array([-0]),Rt=new Uint8Array(vn.buffer);function Bc(e,t,n){vn[0]=e,t[n]=Rt[0],t[n+1]=Rt[1],t[n+2]=Rt[2],t[n+3]=Rt[3]}function _c(e,t){return Rt[0]=e[t],Rt[1]=e[t+1],Rt[2]=e[t+2],Rt[3]=e[t+3],vn[0]}const Bn=new Float64Array([-0]),it=new Uint8Array(Bn.buffer);function Ic(e,t,n){Bn[0]=e,t[n]=it[0],t[n+1]=it[1],t[n+2]=it[2],t[n+3]=it[3],t[n+4]=it[4],t[n+5]=it[5],t[n+6]=it[6],t[n+7]=it[7]}function Lc(e,t){return it[0]=e[t],it[1]=e[t+1],it[2]=e[t+2],it[3]=e[t+3],it[4]=e[t+4],it[5]=e[t+5],it[6]=e[t+6],it[7]=e[t+7],Bn[0]}const Kc=BigInt(Number.MAX_SAFE_INTEGER),Uc=BigInt(Number.MIN_SAFE_INTEGER);class ot{lo;hi;constructor(t,n){this.lo=t|0,this.hi=n|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(n+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(BigInt(n)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,n=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?n===0?t<16384?t<128?1:2:t<2097152?3:4:n<16384?n<128?5:6:n<2097152?7:8:r<128?9:10}static fromBigInt(t){if(t===0n)return Tt;if(t<Kc&&t>Uc)return this.fromNumber(Number(t));const n=t<0n;n&&(t=-t);let r=t>>32n,s=t-(r<<32n);return n&&(r=~r|0n,s=~s|0n,++s>sr&&(s=0n,++r>sr&&(r=0n))),new ot(Number(s),Number(r))}static fromNumber(t){if(t===0)return Tt;const n=t<0;n&&(t=-t);let r=t>>>0,s=(t-r)/4294967296>>>0;return n&&(s=~s>>>0,r=~r>>>0,++r>4294967295&&(r=0,++s>4294967295&&(s=0))),new ot(r,s)}static from(t){return typeof t=="number"?ot.fromNumber(t):typeof t=="bigint"?ot.fromBigInt(t):typeof t=="string"?ot.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new ot(t.low>>>0,t.high>>>0):Tt}}const Tt=new ot(0,0);Tt.toBigInt=function(){return 0n};Tt.zzEncode=Tt.zzDecode=function(){return this};Tt.length=function(){return 1};const sr=4294967296n;function Rc(e){let t=0,n=0;for(let r=0;r<e.length;++r)n=e.charCodeAt(r),n<128?t+=1:n<2048?t+=2:(n&64512)===55296&&(e.charCodeAt(r+1)&64512)===56320?(++r,t+=4):t+=3;return t}function Dc(e,t,n){if(n-t<1)return"";let s;const i=[];let o=0,a;for(;t<n;)a=e[t++],a<128?i[o++]=a:a>191&&a<224?i[o++]=(a&31)<<6|e[t++]&63:a>239&&a<365?(a=((a&7)<<18|(e[t++]&63)<<12|(e[t++]&63)<<6|e[t++]&63)-65536,i[o++]=55296+(a>>10),i[o++]=56320+(a&1023)):i[o++]=(a&15)<<12|(e[t++]&63)<<6|e[t++]&63,o>8191&&((s??(s=[])).push(String.fromCharCode.apply(String,i)),o=0);return s!=null?(o>0&&s.push(String.fromCharCode.apply(String,i.slice(0,o))),s.join("")):String.fromCharCode.apply(String,i.slice(0,o))}function os(e,t,n){const r=n;let s,i;for(let o=0;o<e.length;++o)s=e.charCodeAt(o),s<128?t[n++]=s:s<2048?(t[n++]=s>>6|192,t[n++]=s&63|128):(s&64512)===55296&&((i=e.charCodeAt(o+1))&64512)===56320?(s=65536+((s&1023)<<10)+(i&1023),++o,t[n++]=s>>18|240,t[n++]=s>>12&63|128,t[n++]=s>>6&63|128,t[n++]=s&63|128):(t[n++]=s>>12|224,t[n++]=s>>6&63|128,t[n++]=s&63|128);return n-r}function lt(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function xe(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class Cc{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,lt(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw lt(this,4);return xe(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw lt(this,4);return xe(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw lt(this,4);const t=_c(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw lt(this,4);const t=Lc(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),n=this.pos,r=this.pos+t;if(r>this.len)throw lt(this,t);return this.pos+=t,n===r?new Uint8Array(0):this.buf.subarray(n,r)}string(){const t=this.bytes();return Dc(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw lt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw lt(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new ot(0,0);let n=0;if(this.len-this.pos>4){for(;n<4;++n)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;n=0}else{for(;n<3;++n){if(this.pos>=this.len)throw lt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<n*7)>>>0,t}if(this.len-this.pos>4){for(;n<5;++n)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;n<5;++n){if(this.pos>=this.len)throw lt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw lt(this,8);const t=xe(this.buf,this.pos+=4),n=xe(this.buf,this.pos+=4);return new ot(t,n)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=vc(this.buf,this.pos);return this.pos+=Sn(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function Nc(e){return new Cc(e instanceof Uint8Array?e:e.subarray())}function cs(e,t,n){const r=Nc(e);return t.decode(r,void 0,n)}function Oc(e){let r,s=8192;return function(o){if(o<1||o>4096)return kt(o);s+o>8192&&(r=kt(8192),s=0);const a=r.subarray(s,s+=o);return(s&7)!==0&&(s=(s|7)+1),a}}class te{fn;len;next;val;constructor(t,n,r){this.fn=t,this.len=n,this.next=void 0,this.val=r}}function Je(){}class Tc{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const kc=Oc();function Mc(e){return globalThis.Buffer!=null?kt(e):kc(e)}class un{len;head;tail;states;constructor(){this.len=0,this.head=new te(Je,0,0),this.tail=this.head,this.states=null}_push(t,n,r){return this.tail=this.tail.next=new te(t,n,r),this.len+=n,this}uint32(t){return this.len+=(this.tail=this.tail.next=new $c((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(Ee,10,ot.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const n=ot.fromBigInt(t);return this._push(Ee,n.length(),n)}uint64Number(t){return this._push(Sc,Sn(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const n=ot.fromBigInt(t).zzEncode();return this._push(Ee,n.length(),n)}sint64Number(t){const n=ot.fromNumber(t).zzEncode();return this._push(Ee,n.length(),n)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Qe,1,t?1:0)}fixed32(t){return this._push(Qt,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const n=ot.fromBigInt(t);return this._push(Qt,4,n.lo)._push(Qt,4,n.hi)}fixed64Number(t){const n=ot.fromNumber(t);return this._push(Qt,4,n.lo)._push(Qt,4,n.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(Bc,4,t)}double(t){return this._push(Ic,8,t)}bytes(t){const n=t.length>>>0;return n===0?this._push(Qe,1,0):this.uint32(n)._push(Pc,n,t)}string(t){const n=Rc(t);return n!==0?this.uint32(n)._push(os,n,t):this._push(Qe,1,0)}fork(){return this.states=new Tc(this),this.head=this.tail=new te(Je,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new te(Je,0,0),this.len=0),this}ldelim(){const t=this.head,n=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=t.next,this.tail=n,this.len+=r),this}finish(){let t=this.head.next;const n=Mc(this.len);let r=0;for(;t!=null;)t.fn(t.val,n,r),r+=t.len,t=t.next;return n}}function Qe(e,t,n){t[n]=e&255}function Hc(e,t,n){for(;e>127;)t[n++]=e&127|128,e>>>=7;t[n]=e}class $c extends te{next;constructor(t,n){super(Hc,t,n),this.next=void 0}}function Ee(e,t,n){for(;e.hi!==0;)t[n++]=e.lo&127|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=e.lo&127|128,e.lo=e.lo>>>7;t[n++]=e.lo}function Qt(e,t,n){t[n]=e&255,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function Pc(e,t,n){t.set(e,n)}globalThis.Buffer!=null&&(un.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(Vc,t,e),this},un.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(qc,t,e),this});function Vc(e,t,n){t.set(e,n)}function qc(e,t,n){e.length<40?os(e,t,n):t.utf8Write!=null?t.utf8Write(e,n):t.set(W(e),n)}function zc(){return new un}function as(e,t){const n=zc();return t.encode(e,n,{lengthDelimited:!1}),n.finish()}var Ne;(function(e){e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(Ne||(Ne={}));function us(e,t,n,r){return{name:e,type:t,encode:n,decode:r}}function Fc(e){function t(s){if(e[s.toString()]==null)throw new Error("Invalid enum value");return e[s]}const n=function(i,o){const a=t(i);o.int32(a)},r=function(i){const o=i.int32();return t(o)};return us("enum",Ne.VARINT,n,r)}function fs(e,t){return us("message",Ne.LENGTH_DELIMITED,e,t)}var z;(function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(z||(z={}));var fn;(function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})(fn||(fn={}));(function(e){e.codec=()=>Fc(fn)})(z||(z={}));var Dt;(function(e){let t;e.codec=()=>(t==null&&(t=fs((n,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),z.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),s.lengthDelimited!==!1&&r.ldelim()},(n,r,s={})=>{const i={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const a=n.uint32();switch(a>>>3){case 1:{i.Type=z.codec().decode(n);break}case 2:{i.Data=n.bytes();break}default:{n.skipType(a&7);break}}}return i})),t),e.encode=n=>as(n,e.codec()),e.decode=(n,r)=>cs(n,e.codec(),r)})(Dt||(Dt={}));var Oe;(function(e){let t;e.codec=()=>(t==null&&(t=fs((n,r,s={})=>{s.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),z.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),s.lengthDelimited!==!1&&r.ldelim()},(n,r,s={})=>{const i={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const a=n.uint32();switch(a>>>3){case 1:{i.Type=z.codec().decode(n);break}case 2:{i.Data=n.bytes();break}default:{n.skipType(a&7);break}}}return i})),t),e.encode=n=>as(n,e.codec()),e.decode=(n,r)=>cs(n,e.codec(),r)})(Oe||(Oe={}));class _n{type="RSA";jwk;_raw;_multihash;constructor(t,n){this.jwk=t,this._multihash=n}get raw(){return this._raw==null&&(this._raw=Ln(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return G.createV1(114,this._multihash)}toString(){return ht.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}verify(t,n,r){return sa(this.jwk,n,t,r)}}class hs{type="RSA";jwk;_raw;publicKey;constructor(t,n){this.jwk=t,this.publicKey=n}get raw(){return this._raw==null&&(this._raw=Gc(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}sign(t,n){return ra(this.jwk,t,n)}}const ls=8192,In=18,Zc=1062,jc=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function Yc(e){return{n:P(e[1],"base64url"),e:P(e[2],"base64url"),d:P(e[3],"base64url"),p:P(e[4],"base64url"),q:P(e[5],"base64url"),dp:P(e[6],"base64url"),dq:P(e[7],"base64url"),qi:P(e[8],"base64url"),kty:"RSA"}}function Gc(e){if(e.n==null||e.e==null||e.d==null||e.p==null||e.q==null||e.dp==null||e.dq==null||e.qi==null)throw new V("JWK was missing components");return Et([ft(Uint8Array.from([0])),ft(W(e.n,"base64url")),ft(W(e.e,"base64url")),ft(W(e.d,"base64url")),ft(W(e.p,"base64url")),ft(W(e.q,"base64url")),ft(W(e.dp,"base64url")),ft(W(e.dq,"base64url")),ft(W(e.qi,"base64url"))]).subarray()}function Xc(e){const t=Ct(e[1],{offset:0});return{kty:"RSA",n:P(t[0],"base64url"),e:P(t[1],"base64url")}}function Ln(e){if(e.n==null||e.e==null)throw new V("JWK was missing components");return Et([jc,yn(Et([ft(W(e.n,"base64url")),ft(W(e.e,"base64url"))]))]).subarray()}function Wc(e){const t=Ct(e);return ds(t)}function ds(e){const t=Yc(e);return ys(t)}function Jc(e,t){if(e.byteLength>=Zc)throw new cr("Key size is too large");const n=Ct(e,{offset:0});return bs(n,e,t)}function bs(e,t,n){const r=Xc(e);if(n==null){const s=$e(Dt.encode({Type:z.RSA,Data:t}));n=Xt(In,s)}return new _n(r,n)}function ys(e){if(oa(e)>ls)throw new V("Key size is too large");const t=ta(e),n=$e(Dt.encode({Type:z.RSA,Data:Ln(t.publicKey)})),r=Xt(In,n);return new hs(t.privateKey,new _n(t.publicKey,r))}async function Qc(e){if(e>ls)throw new V("Key size is too large");const t=await na(e),n=$e(Dt.encode({Type:z.RSA,Data:Ln(t.publicKey)})),r=Xt(In,n);return new hs(t.privateKey,new _n(t.publicKey,r))}function ta(e){if(e==null)throw new V("Missing key parameter");return{privateKey:e,publicKey:{kty:e.kty,n:e.n,e:e.e}}}const ea="1.2.840.113549.1.1.1";async function na(e,t){const n=await J.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),r=await ia(n);return{privateKey:r[0],publicKey:r[1]}}async function ra(e,t,n){const r=await J.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);n?.signal?.throwIfAborted();const s=await J.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},r,t instanceof Uint8Array?t:t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(s,0,s.byteLength)}async function sa(e,t,n,r){const s=await J.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);r?.signal?.throwIfAborted();const i=await J.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},s,t,n instanceof Uint8Array?n:n.subarray());return r?.signal?.throwIfAborted(),i}async function ia(e,t){if(e.privateKey==null||e.publicKey==null)throw new V("Private and public key are required");return await Promise.all([J.get().subtle.exportKey("jwk",e.privateKey),J.get().subtle.exportKey("jwk",e.publicKey)])}function oa(e){if(e.kty!=="RSA")throw new V("invalid key type");if(e.n==null)throw new V("invalid key modulus");return W(e.n,"base64url").length*8}class ws{oHash;iHash;blockLen;outputLen;finished=!1;destroyed=!1;constructor(t,n){if(Lr(t),$(n,void 0,"key"),this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,s=new Uint8Array(r);s.set(n.length>r?t.create().update(n).digest():n);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),Yt(s)}update(t){return Ke(this),this.iHash.update(t),this}digestInto(t){Ke(this),$(t,this.outputLen,"output"),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||=Object.create(Object.getPrototypeOf(this),{});const{oHash:n,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:a}=this;return t=t,t.finished=s,t.destroyed=i,t.blockLen=o,t.outputLen=a,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const gs=(e,t,n)=>new ws(e,t).update(n).digest();gs.create=(e,t)=>new ws(e,t);const ir=(e,t)=>(e+(e>=0?t:-t)/ps)/t;function ca(e,t,n){const[[r,s],[i,o]]=t,a=ir(o*e,n),c=ir(-s*e,n);let u=e-a*r-c*i,y=-a*s-c*o;const f=u<xt,x=y<xt;f&&(u=-u),x&&(y=-y);const E=mn(Math.ceil(Oo(n)/2))+Zt;if(u<xt||u>=E||y<xt||y>=E)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:f,k1:u,k2neg:x,k2:y}}function hn(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function tn(e,t){const n={};for(let r of Object.keys(t))n[r]=e[r]===void 0?t[r]:e[r];return Ht(n.lowS,"lowS"),Ht(n.prehash,"prehash"),n.format!==void 0&&hn(n.format),n}class aa extends Error{constructor(t=""){super(t)}}const Ut={Err:aa,_tlv:{encode:(e,t)=>{const{Err:n}=Ut;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length&1)throw new n("tlv.encode: unpadded data");const r=t.length/2,s=me(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?me(s.length/2|128):"";return me(e)+i+s+t},decode(e,t){const{Err:n}=Ut;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const s=t[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const c=s&127;if(!c)throw new n("tlv.decode(long): indefinite length not supported");if(c>4)throw new n("tlv.decode(long): byte length is too big");const u=t.subarray(r,r+c);if(u.length!==c)throw new n("tlv.decode: length bytes not complete");if(u[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const y of u)o=o<<8|y;if(r+=c,o<128)throw new n("tlv.decode(long): not minimal encoding")}const a=t.subarray(r,r+o);if(a.length!==o)throw new n("tlv.decode: wrong value length");return{v:a,l:t.subarray(r+o)}}},_int:{encode(e){const{Err:t}=Ut;if(e<xt)throw new t("integer: negative integers are not allowed");let n=me(e);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=Ut;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Pe(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=Ut,s=$(e,void 0,"signature"),{v:i,l:o}=r.decode(48,s);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:a,l:c}=r.decode(2,i),{v:u,l:y}=r.decode(2,c);if(y.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(a),s:n.decode(u)}},hexFromSig(e){const{_tlv:t,_int:n}=Ut,r=t.encode(2,n.encode(e.r)),s=t.encode(2,n.encode(e.s)),i=r+s;return t.encode(48,i)}},xt=BigInt(0),Zt=BigInt(1),ps=BigInt(2),Ae=BigInt(3),ua=BigInt(4);function fa(e,t={}){const n=Xr("weierstrass",e,t),{Fp:r,Fn:s}=n;let i=n.CURVE;const{h:o,n:a}=i;de(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:c}=t;if(c&&(!r.is0(i.a)||typeof c.beta!="bigint"||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=xs(r,s);function y(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function f(U,d,b){const{x:h,y:S}=d.toAffine(),I=r.toBytes(h);if(Ht(b,"isCompressed"),b){y();const K=!r.isOdd(S);return wt(ms(K),I)}else return wt(Uint8Array.of(4),I,r.toBytes(S))}function x(U){$(U,void 0,"Point");const{publicKey:d,publicKeyUncompressed:b}=u,h=U.length,S=U[0],I=U.subarray(1);if(h===d&&(S===2||S===3)){const K=r.fromBytes(I);if(!r.isValid(K))throw new Error("bad point: is not on curve, wrong x");const R=B(K);let L;try{L=r.sqrt(R)}catch(F){const q=F instanceof Error?": "+F.message:"";throw new Error("bad point: is not on curve, sqrt error"+q)}y();const D=r.isOdd(L);return(S&1)===1!==D&&(L=r.neg(L)),{x:K,y:L}}else if(h===b&&S===4){const K=r.BYTES,R=r.fromBytes(I.subarray(0,K)),L=r.fromBytes(I.subarray(K,K*2));if(!v(R,L))throw new Error("bad point: is not on curve");return{x:R,y:L}}else throw new Error(`bad point: got length ${h}, expected compressed=${d} or uncompressed=${b}`)}const E=t.toBytes||f,l=t.fromBytes||x;function B(U){const d=r.sqr(U),b=r.mul(d,U);return r.add(r.add(b,r.mul(U,i.a)),i.b)}function v(U,d){const b=r.sqr(d),h=B(U);return r.eql(b,h)}if(!v(i.Gx,i.Gy))throw new Error("bad curve params: generator point");const w=r.mul(r.pow(i.a,Ae),ua),A=r.mul(r.sqr(i.b),BigInt(27));if(r.is0(r.add(w,A)))throw new Error("bad curve params: a or b");function g(U,d,b=!1){if(!r.isValid(d)||b&&r.is0(d))throw new Error(`bad point coordinate ${U}`);return d}function _(U){if(!(U instanceof p))throw new Error("Weierstrass Point expected")}function C(U){if(!c||!c.basises)throw new Error("no endo");return ca(U,c.basises,s.ORDER)}const T=Ue((U,d)=>{const{X:b,Y:h,Z:S}=U;if(r.eql(S,r.ONE))return{x:b,y:h};const I=U.is0();d==null&&(d=I?r.ONE:r.inv(S));const K=r.mul(b,d),R=r.mul(h,d),L=r.mul(S,d);if(I)return{x:r.ZERO,y:r.ZERO};if(!r.eql(L,r.ONE))throw new Error("invZ was invalid");return{x:K,y:R}}),k=Ue(U=>{if(U.is0()){if(t.allowInfinityPoint&&!r.is0(U.Y))return;throw new Error("bad point: ZERO")}const{x:d,y:b}=U.toAffine();if(!r.isValid(d)||!r.isValid(b))throw new Error("bad point: x or y not field elements");if(!v(d,b))throw new Error("bad point: equation left != right");if(!U.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function m(U,d,b,h,S){return b=new p(r.mul(b.X,U),b.Y,b.Z),d=Re(h,d),b=Re(S,b),d.add(b)}class p{static BASE=new p(i.Gx,i.Gy,r.ONE);static ZERO=new p(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=s;X;Y;Z;constructor(d,b,h){this.X=g("x",d),this.Y=g("y",b,!0),this.Z=g("z",h),Object.freeze(this)}static CURVE(){return i}static fromAffine(d){const{x:b,y:h}=d||{};if(!d||!r.isValid(b)||!r.isValid(h))throw new Error("invalid affine point");if(d instanceof p)throw new Error("projective point not allowed");return r.is0(b)&&r.is0(h)?p.ZERO:new p(b,h,r.ONE)}static fromBytes(d){const b=p.fromAffine(l($(d,void 0,"point")));return b.assertValidity(),b}static fromHex(d){return p.fromBytes(se(d))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(d=8,b=!0){return M.createCache(this,d),b||this.multiply(Ae),this}assertValidity(){k(this)}hasEvenY(){const{y:d}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(d)}equals(d){_(d);const{X:b,Y:h,Z:S}=this,{X:I,Y:K,Z:R}=d,L=r.eql(r.mul(b,R),r.mul(I,S)),D=r.eql(r.mul(h,R),r.mul(K,S));return L&&D}negate(){return new p(this.X,r.neg(this.Y),this.Z)}double(){const{a:d,b}=i,h=r.mul(b,Ae),{X:S,Y:I,Z:K}=this;let R=r.ZERO,L=r.ZERO,D=r.ZERO,O=r.mul(S,S),F=r.mul(I,I),q=r.mul(K,K),H=r.mul(S,I);return H=r.add(H,H),D=r.mul(S,K),D=r.add(D,D),R=r.mul(d,D),L=r.mul(h,q),L=r.add(R,L),R=r.sub(F,L),L=r.add(F,L),L=r.mul(R,L),R=r.mul(H,R),D=r.mul(h,D),q=r.mul(d,q),H=r.sub(O,q),H=r.mul(d,H),H=r.add(H,D),D=r.add(O,O),O=r.add(D,O),O=r.add(O,q),O=r.mul(O,H),L=r.add(L,O),q=r.mul(I,K),q=r.add(q,q),O=r.mul(q,H),R=r.sub(R,O),D=r.mul(q,F),D=r.add(D,D),D=r.add(D,D),new p(R,L,D)}add(d){_(d);const{X:b,Y:h,Z:S}=this,{X:I,Y:K,Z:R}=d;let L=r.ZERO,D=r.ZERO,O=r.ZERO;const F=i.a,q=r.mul(i.b,Ae);let H=r.mul(b,I),Z=r.mul(h,K),tt=r.mul(S,R),dt=r.add(b,h),j=r.add(I,K);dt=r.mul(dt,j),j=r.add(H,Z),dt=r.sub(dt,j),j=r.add(b,S);let rt=r.add(I,R);return j=r.mul(j,rt),rt=r.add(H,tt),j=r.sub(j,rt),rt=r.add(h,S),L=r.add(K,R),rt=r.mul(rt,L),L=r.add(Z,tt),rt=r.sub(rt,L),O=r.mul(F,j),L=r.mul(q,tt),O=r.add(L,O),L=r.sub(Z,O),O=r.add(Z,O),D=r.mul(L,O),Z=r.add(H,H),Z=r.add(Z,H),tt=r.mul(F,tt),j=r.mul(q,j),Z=r.add(Z,tt),tt=r.sub(H,tt),tt=r.mul(F,tt),j=r.add(j,tt),H=r.mul(Z,j),D=r.add(D,H),H=r.mul(rt,j),L=r.mul(dt,L),L=r.sub(L,H),H=r.mul(dt,Z),O=r.mul(rt,O),O=r.add(O,H),new p(L,D,O)}subtract(d){return this.add(d.negate())}is0(){return this.equals(p.ZERO)}multiply(d){const{endo:b}=t;if(!s.isValidNot0(d))throw new Error("invalid scalar: out of range");let h,S;const I=K=>M.cached(this,K,R=>re(p,R));if(b){const{k1neg:K,k1:R,k2neg:L,k2:D}=C(d),{p:O,f:F}=I(R),{p:q,f:H}=I(D);S=F.add(H),h=m(b.beta,O,q,K,L)}else{const{p:K,f:R}=I(d);h=K,S=R}return re(p,[h,S])[0]}multiplyUnsafe(d){const{endo:b}=t,h=this;if(!s.isValid(d))throw new Error("invalid scalar: out of range");if(d===xt||h.is0())return p.ZERO;if(d===Zt)return h;if(M.hasCache(this))return this.multiply(d);if(b){const{k1neg:S,k1:I,k2neg:K,k2:R}=C(d),{p1:L,p2:D}=Go(p,h,I,R);return m(b.beta,L,D,S,K)}else return M.unsafe(h,d)}toAffine(d){return T(this,d)}isTorsionFree(){const{isTorsionFree:d}=t;return o===Zt?!0:d?d(p,this):M.unsafe(this,a).is0()}clearCofactor(){const{clearCofactor:d}=t;return o===Zt?this:d?d(p,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(d=!0){return Ht(d,"isCompressed"),this.assertValidity(),E(p,this,d)}toHex(d=!0){return le(this.toBytes(d))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const N=s.BITS,M=new Gr(p,t.endo?Math.ceil(N/2):N);return p.BASE.precompute(8),p}function ms(e){return Uint8Array.of(e?2:3)}function xs(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function ha(e,t={}){const{Fn:n}=e,r=t.randomBytes||wn,s=Object.assign(xs(e.Fp,n),{seed:Zr(n.ORDER)});function i(E){try{const l=n.fromBytes(E);return n.isValidNot0(l)}catch{return!1}}function o(E,l){const{publicKey:B,publicKeyUncompressed:v}=s;try{const w=E.length;return l===!0&&w!==B||l===!1&&w!==v?!1:!!e.fromBytes(E)}catch{return!1}}function a(E=r(s.seed)){return Yo($(E,s.seed,"seed"),n.ORDER)}function c(E,l=!0){return e.BASE.multiply(n.fromBytes(E)).toBytes(l)}function u(E){const{secretKey:l,publicKey:B,publicKeyUncompressed:v}=s;if(!He(E)||"_lengths"in n&&n._lengths||l===B)return;const w=$(E,void 0,"key").length;return w===B||w===v}function y(E,l,B=!0){if(u(E)===!0)throw new Error("first arg must be private key");if(u(l)===!1)throw new Error("second arg must be public key");const v=n.fromBytes(E);return e.fromBytes(l).multiply(v).toBytes(B)}const f={isValidSecretKey:i,isValidPublicKey:o,randomSecretKey:a},x=Wr(a,c);return Object.freeze({getPublicKey:c,getSharedSecret:y,keygen:x,Point:e,utils:f,lengths:s})}function la(e,t,n={}){Lr(t),de(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);const r=n.randomBytes||wn,s=n.hmac||((b,h)=>gs(t,b,h)),{Fp:i,Fn:o}=e,{ORDER:a,BITS:c}=o,{keygen:u,getPublicKey:y,getSharedSecret:f,utils:x,lengths:E}=ha(e,n),l={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},B=a*ps<i.ORDER;function v(b){const h=a>>Zt;return b>h}function w(b,h){if(!o.isValidNot0(h))throw new Error(`invalid signature ${b}: out of range 1..Point.Fn.ORDER`);return h}function A(){if(B)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function g(b,h){hn(h);const S=E.signature,I=h==="compact"?S:h==="recovered"?S+1:void 0;return $(b,I)}class _{r;s;recovery;constructor(h,S,I){if(this.r=w("r",h),this.s=w("s",S),I!=null){if(A(),![0,1,2,3].includes(I))throw new Error("invalid recovery id");this.recovery=I}Object.freeze(this)}static fromBytes(h,S=l.format){g(h,S);let I;if(S==="der"){const{r:D,s:O}=Ut.toSig($(h));return new _(D,O)}S==="recovered"&&(I=h[0],S="compact",h=h.subarray(1));const K=E.signature/2,R=h.subarray(0,K),L=h.subarray(K,K*2);return new _(o.fromBytes(R),o.fromBytes(L),I)}static fromHex(h,S){return this.fromBytes(se(h),S)}assertRecovery(){const{recovery:h}=this;if(h==null)throw new Error("invalid recovery id: must be present");return h}addRecoveryBit(h){return new _(this.r,this.s,h)}recoverPublicKey(h){const{r:S,s:I}=this,K=this.assertRecovery(),R=K===2||K===3?S+a:S;if(!i.isValid(R))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const L=i.toBytes(R),D=e.fromBytes(wt(ms((K&1)===0),L)),O=o.inv(R),F=T($(h,void 0,"msgHash")),q=o.create(-F*O),H=o.create(I*O),Z=e.BASE.multiplyUnsafe(q).add(D.multiplyUnsafe(H));if(Z.is0())throw new Error("invalid recovery: point at infinify");return Z.assertValidity(),Z}hasHighS(){return v(this.s)}toBytes(h=l.format){if(hn(h),h==="der")return se(Ut.hexFromSig(this));const{r:S,s:I}=this,K=o.toBytes(S),R=o.toBytes(I);return h==="recovered"?(A(),wt(Uint8Array.of(this.assertRecovery()),K,R)):wt(K,R)}toHex(h){return le(this.toBytes(h))}}const C=n.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const S=Pe(h),I=h.length*8-c;return I>0?S>>BigInt(I):S},T=n.bits2int_modN||function(h){return o.create(C(h))},k=mn(c);function m(b){return an("num < 2^"+c,b,xt,k),o.toBytes(b)}function p(b,h){return $(b,void 0,"message"),h?$(t(b),void 0,"prehashed message"):b}function N(b,h,S){const{lowS:I,prehash:K,extraEntropy:R}=tn(S,l);b=p(b,K);const L=T(b),D=o.fromBytes(h);if(!o.isValidNot0(D))throw new Error("invalid private key");const O=[m(D),m(L)];if(R!=null&&R!==!1){const Z=R===!0?r(E.secretKey):R;O.push($(Z,void 0,"extraEntropy"))}const F=wt(...O),q=L;function H(Z){const tt=C(Z);if(!o.isValidNot0(tt))return;const dt=o.inv(tt),j=e.BASE.multiply(tt).toAffine(),rt=o.create(j.x);if(rt===xt)return;const be=o.create(dt*o.create(q+rt*D));if(be===xt)return;let Dn=(j.x===rt?0:2)|Number(j.y&Zt),Cn=be;return I&&v(be)&&(Cn=o.neg(be),Dn^=1),new _(rt,Cn,B?void 0:Dn)}return{seed:F,k2sig:H}}function M(b,h,S={}){const{seed:I,k2sig:K}=N(b,h,S);return To(t.outputLen,o.BYTES,s)(I,K).toBytes(S.format)}function U(b,h,S,I={}){const{lowS:K,prehash:R,format:L}=tn(I,l);if(S=$(S,void 0,"publicKey"),h=p(h,R),!He(b)){const D=b instanceof _?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+D)}g(b,L);try{const D=_.fromBytes(b,L),O=e.fromBytes(S);if(K&&D.hasHighS())return!1;const{r:F,s:q}=D,H=T(h),Z=o.inv(q),tt=o.create(H*Z),dt=o.create(F*Z),j=e.BASE.multiplyUnsafe(tt).add(O.multiplyUnsafe(dt));return j.is0()?!1:o.create(j.x)===F}catch{return!1}}function d(b,h,S={}){const{prehash:I}=tn(S,l);return h=p(h,I),_.fromBytes(b,"recovered").recoverPublicKey(h).toBytes()}return Object.freeze({keygen:u,getPublicKey:y,getSharedSecret:f,utils:x,lengths:E,Point:e,sign:M,verify:U,recoverPublicKey:d,Signature:_,hash:t})}const Kn={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},da={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},or=BigInt(2);function ba(e){const t=Kn.p,n=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,y=u*u*e%t,f=Y(y,n,t)*y%t,x=Y(f,n,t)*y%t,E=Y(x,or,t)*u%t,l=Y(E,s,t)*E%t,B=Y(l,i,t)*l%t,v=Y(B,a,t)*B%t,w=Y(v,c,t)*v%t,A=Y(w,a,t)*B%t,g=Y(A,n,t)*y%t,_=Y(g,o,t)*l%t,C=Y(_,r,t)*u%t,T=Y(C,or,t);if(!ln.eql(ln.sqr(T),e))throw new Error("Cannot find square root");return T}const ln=Ve(Kn.p,{sqrt:ba}),ya=fa(Kn,{Fp:ln,endo:da}),At=la(ya,$e),wa=33,ga=32;function pa(e,t,n){const r=yr.digest(t instanceof Uint8Array?t:t.subarray());if(qe(r))return r.then(({digest:s})=>(n?.signal?.throwIfAborted(),At.sign(s,e,{prehash:!1,format:"der"}))).catch(s=>{throw s.name==="AbortError"?s:new er(String(s))});try{return At.sign(r.digest,e,{prehash:!1,format:"der"})}catch(s){throw new er(String(s))}}function ma(e,t,n,r){const s=yr.digest(n instanceof Uint8Array?n:n.subarray());if(qe(s))return s.then(({digest:i})=>(r?.signal?.throwIfAborted(),At.verify(t,i,e,{prehash:!1,format:"der"}))).catch(i=>{throw i.name==="AbortError"?i:new nr(String(i))});try{return r?.signal?.throwIfAborted(),At.verify(t,s.digest,e,{prehash:!1,format:"der"})}catch(i){throw new nr(String(i))}}class Es{type="secp256k1";raw;_key;constructor(t){this._key=Sa(t),this.raw=Ea(this._key)}toMultihash(){return bn.digest(Fe(this))}toCID(){return G.createV1(114,this.toMultihash())}toString(){return ht.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}verify(t,n,r){return ma(this._key,n,t,r)}}class As{type="secp256k1";raw;publicKey;constructor(t,n){this.raw=Aa(t),this.publicKey=new Es(n??va(t))}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:gt(this.raw,t.raw)}sign(t,n){return pa(this.raw,t,n)}}function Ss(e){return new As(e)}function Un(e){return new Es(e)}async function xa(){const e=Ba();return new As(e)}function Ea(e){return At.Point.fromBytes(e).toBytes()}function Aa(e){try{return At.getPublicKey(e,!0),e}catch(t){throw new ar(String(t))}}function Sa(e){try{return At.Point.fromBytes(e),e}catch(t){throw new cr(String(t))}}function va(e){try{return At.getPublicKey(e,!0)}catch(t){throw new ar(String(t))}}function Ba(){return At.utils.randomSecretKey()}const ze={"P-256":32,"P-384":48,"P-521":66},_a=Object.keys(ze),Rn=_a.join(" / ");async function Ia(e){if(e!=="P-256"&&e!=="P-384"&&e!=="P-521")throw new V(`Unknown curve: ${e}. Must be ${Rn}`);const t=await J.get().subtle.generateKey({name:"ECDH",namedCurve:e},!0,["deriveBits"]),n=async(i,o)=>{let a;o!=null?a=await J.get().subtle.importKey("jwk",Ka(e,o),{name:"ECDH",namedCurve:e},!1,["deriveBits"]):a=t.privateKey;const c=await J.get().subtle.importKey("jwk",vs(e,i),{name:"ECDH",namedCurve:e},!1,[]),u=await J.get().subtle.deriveBits({name:"ECDH",public:c},a,ze[e]*8);return new Uint8Array(u,0,u.byteLength)},r=await J.get().subtle.exportKey("jwk",t.publicKey);return{key:La(r),genSharedKey:n}}function La(e){if(e.crv==null||e.x==null||e.y==null)throw new V("JWK was missing components");if(e.crv!=="P-256"&&e.crv!=="P-384"&&e.crv!=="P-521")throw new V(`Unknown curve: ${e.crv}. Must be ${Rn}`);const t=ze[e.crv];return jt([Uint8Array.from([4]),rr(e.x,t),rr(e.y,t)],1+t*2)}function vs(e,t){if(e!=="P-256"&&e!=="P-384"&&e!=="P-521")throw new V(`Unknown curve: ${e}. Must be ${Rn}`);const n=ze[e];if(!gt(t.subarray(0,1),Uint8Array.from([4])))throw new V("Cannot unmarshal public key - invalid key format");return{kty:"EC",crv:e,x:P(t.subarray(1,n+1),"base64url"),y:P(t.subarray(1+n),"base64url"),ext:!0}}const Ka=(e,t)=>({...vs(e,t.public),d:P(t.private,"base64url")}),Ua={SHA1:20,SHA256:32,SHA512:64},Ra={SHA1:"SHA-1",SHA256:"SHA-256",SHA512:"SHA-512"},Da=async(e,t)=>{const n=await J.get().subtle.sign({name:"HMAC"},e,t);return new Uint8Array(n,0,n.byteLength)};async function Ca(e,t){const n=Ra[e],r=await J.get().subtle.importKey("raw",t,{name:"HMAC",hash:{name:n}},!1,["sign"]);return{async digest(s){return Da(r,s)},length:Ua[e]}}const Na={"AES-128":{ivSize:16,keySize:16},"AES-256":{ivSize:16,keySize:32},Blowfish:{ivSize:8,keySize:32}};async function Oa(e,t,n){if(e!=="AES-128"&&e!=="AES-256"&&e!=="Blowfish")throw new V("Cipher type was missing or unsupported");if(t!=="SHA1"&&t!=="SHA256"&&t!=="SHA512")throw new V("Hash type was missing or unsupported");if(n==null||!(n instanceof Uint8Array))throw new V("Secret was missing or an incorrect type");const r=Na[e],s=r.keySize,i=r.ivSize,o=20,a=W("key expansion"),c=2*(i+s+o),u=await Ca(t,n);let y=await u.digest(a);const f=[];let x=0;for(;x<c;){const A=await u.digest(jt([y,a]));let g=A.length;x+g>c&&(g=c-x),f.push(A),x+=g,y=await u.digest(y)}const E=c/2,l=jt(f),B=l.subarray(0,E),v=l.subarray(E,c),w=A=>({iv:A.subarray(0,i),cipherKey:A.subarray(i,i+s),macKey:A.subarray(i+s)});return{k1:w(B),k2:w(v)}}async function Ta(e,t){if(e==="Ed25519")return pc();if(e==="secp256k1")return xa();if(e==="RSA")return Qc(za(t));if(e==="ECDSA")return lo(Fa(t));throw new ue}async function ka(e,t){if(e!=="Ed25519")throw new ue("Seed key derivation only supported for Ed25519 keys");return mc(t)}function Ma(e,t){const{Type:n,Data:r}=Dt.decode(e),s=r??new Uint8Array;switch(n){case z.RSA:return Jc(s,t);case z.Ed25519:return An(s);case z.secp256k1:return Un(s);case z.ECDSA:return Br(s);default:throw new ue}}function Ha(e){if(e.byteLength===ce)return An(e);if(e.byteLength===wa)return Un(e);const t=Ct(e),n=t[1]?.[0];if(n===pr||n===mr||n===xr)return _r(t);if(t[0]?.[0]===ea)return bs(t,e);throw new V("Could not extract public key from raw bytes")}function $a(e){const{Type:t,Data:n}=Dt.decode(e.digest),r=n??new Uint8Array;switch(t){case z.Ed25519:return An(r);case z.secp256k1:return Un(r);case z.ECDSA:return Br(r);default:throw new ue}}function Fe(e){return Dt.encode({Type:z[e.type],Data:e.raw})}function Pa(e){const t=Oe.decode(e),n=t.Data??new Uint8Array;switch(t.Type){case z.RSA:return Wc(n);case z.Ed25519:return es(n);case z.secp256k1:return Ss(n);case z.ECDSA:return uo(n);default:throw new ue}}function Va(e){if(e.byteLength===yt)return es(e);if(e.byteLength===ga)return Ss(e);const t=Ct(e),n=t[2]?.[0];if(n===pr||n===mr||n===xr)return vr(t);if(t.length>8)return ds(t);throw new V("Could not extract private key from raw bytes")}function qa(e){return Oe.encode({Type:z[e.type],Data:e.raw})}function za(e){return e==null?2048:parseInt(e,10)}function Fa(e){if(e==="P-256"||e==null)return"P-256";if(e==="P-384")return"P-384";if(e==="P-521")return"P-521";throw new V("Unsupported curve, should be P-256, P-384 or P-521")}async function Za(e){if(e.type==="RSA")return{privateKey:await crypto.subtle.importKey("jwk",e.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",e.publicKey.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])};if(e.type==="ECDSA")return{privateKey:await crypto.subtle.importKey("jwk",e.jwk,{name:"ECDSA",namedCurve:e.jwk.crv??"P-256"},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",e.publicKey.jwk,{name:"ECDSA",namedCurve:e.publicKey.jwk.crv??"P-256"},!0,["verify"])};throw new V("Only RSA and ECDSA keys are supported")}async function ja(e){if(e.privateKey.algorithm.name==="RSASSA-PKCS1-v1_5"){const t=await crypto.subtle.exportKey("jwk",e.privateKey);return ys(t)}if(e.privateKey.algorithm.name==="ECDSA"){const t=await crypto.subtle.exportKey("jwk",e.privateKey);return new ne(t)}throw new V("Only RSA and ECDSA keys are supported")}const Xa=Object.freeze(Object.defineProperty({__proto__:null,generateEphemeralKeyPair:Ia,generateKeyPair:Ta,generateKeyPairFromSeed:ka,keyStretcher:Oa,privateKeyFromCryptoKeyPair:ja,privateKeyFromProtobuf:Pa,privateKeyFromRaw:Va,privateKeyToCryptoKeyPair:Za,privateKeyToProtobuf:qa,publicKeyFromMultihash:$a,publicKeyFromProtobuf:Ma,publicKeyFromRaw:Ha,publicKeyToProtobuf:Fe},Symbol.toStringTag,{value:"Module"}));export{G as C,Ya as I,ue as U,Ga as a,ht as b,V as c,di as d,gt as e,W as f,ee as g,Oi as h,bn as i,Fc as j,as as k,cs as l,fs as m,Ma as n,jt as o,$a as p,Se as q,Fe as r,yr as s,P as t,Xa as u};
