================================================================================
IPFS FAST SYNC - QUICK REFERENCE CARD
================================================================================

TARGET: Sub-2 second wallet token synchronization
STATUS: Architecture Complete | Code Complete | Ready for Implementation

================================================================================
PERFORMANCE COMPARISON
================================================================================

                BEFORE (DHT)        AFTER (HTTP)        IMPROVEMENT
─────────────────────────────────────────────────────────────────────────────
IPNS Resolve    10-30 seconds       100-300 ms          30-100x faster
Content Fetch   10-30 seconds       50-200 ms           50-100x faster
Total Sync      30-60 seconds       <500 ms             60-100x faster
Cached Sync     N/A                 <10 ms              ∞

================================================================================
ARCHITECTURE (3-Tier Model)
================================================================================

┌────────────────────────────────────────┐
│ 1. CACHE (0-5ms) - Local memory        │
│    ├─ IPNS records: 60s TTL            │
│    ├─ Content: Infinite TTL (by CID)   │
│    └─ Failures: 30s backoff            │
├────────────────────────────────────────┤
│ 2. HTTP API (100-300ms) - Fast path    │
│    ├─ Query all 5 nodes in parallel    │
│    ├─ Gateway path: /ipns/{name}       │
│    └─ Routing API: /api/v0/routing/get │
├────────────────────────────────────────┤
│ 3. DHT FALLBACK (>1s) - Compatibility  │
│    └─ Only if HTTP fails, 1s timeout   │
└────────────────────────────────────────┘

================================================================================
KEY HTTP ENDPOINTS
================================================================================

IPNS RESOLUTION (Choose One or Both):

1. Gateway Path (FAST - 30-100ms):
   GET /ipns/{ipnsName}?format=dag-json
   Returns: Token content directly

2. Routing API (RELIABLE - 200-300ms):
   POST /api/v0/routing/get?arg=/ipns/{ipnsName}
   Returns: IPNS record with sequence number

CONTENT FETCH (IMMUTABLE - 50-200ms):
   GET /ipfs/{cid}?format=dag-json
   Returns: Token data by content hash

IPNS PUBLISH (MULTI-NODE - 150-500ms):
   POST /api/v0/name/publish?arg=/ipfs/{cid}&lifetime=87660h
   Returns: IPNS name and value

================================================================================
PARALLEL MULTI-NODE STRATEGY
================================================================================

Query all 5 nodes simultaneously:
   Node 1 ─┐
   Node 2 ─┼─→ Promise.any() ─→ First Success (100-300ms)
   Node 3 ─┤
   Node 4 ─┤
   Node 5 ─┘

Benefits:
  • Even if 1-2 nodes are slow/down, others respond quickly
  • Typical winner completes in 100-300ms
  • Resilient to network/node failures

================================================================================
IMPLEMENTATION TIMELINE
================================================================================

WEEK 1:
  Day 1-2: Implement 4 services (Cache, Resolver, Publisher, Metrics)
  Day 3-4: Integrate into IpfsStorageService
  Day 5:   Configuration + Kubo node setup

WEEK 2:
  Day 7-10: Testing (unit, integration, performance)
  Day 11-12: Documentation + monitoring dashboard
  Day 13-14: Staging validation

WEEK 3+:
  Day 15+: Production deployment + monitoring

Total: ~10 development days

================================================================================
FILES TO CREATE/MODIFY
================================================================================

NEW SERVICES (Production Ready):
  src/components/wallet/L3/services/
  ├── IpfsCache.ts              (150 lines - cache layer)
  ├── IpfsHttpResolver.ts       (400 lines - HTTP resolution)
  ├── IpfsPublisher.ts          (250 lines - multi-node publish)
  └── IpfsMetrics.ts            (300 lines - metrics tracking)

DOCUMENTATION (Complete):
  docs/
  ├── README_IPFS_FAST_SYNC.md        (Master reference)
  ├── IPFS_FAST_SYNC_SUMMARY.md       (Executive summary)
  ├── IPFS_SYNC_STRATEGY.md           (Detailed design)
  ├── IPFS_INTEGRATION_GUIDE.md       (How to integrate)
  └── IPFS_IMPLEMENTATION_CHECKLIST.md (Execution plan)

MODIFICATIONS:
  src/components/wallet/L3/services/
  └── IpfsStorageService.ts     (Update sync() + publish())

  src/config/
  └── ipfs.config.ts            (Add HTTP timeouts)

================================================================================
INTEGRATION CHECKLIST
================================================================================

PHASE 1: Copy Services
  [ ] Copy IpfsCache.ts to src/components/wallet/L3/services/
  [ ] Copy IpfsHttpResolver.ts
  [ ] Copy IpfsPublisher.ts
  [ ] Copy IpfsMetrics.ts

PHASE 2: Update IpfsStorageService
  [ ] Update sync() method to use IpfsHttpResolver
  [ ] Update publish() method to use IpfsPublisher
  [ ] Add metrics recording

PHASE 3: Configuration
  [ ] Update ipfs.config.ts with HTTP timeouts
  [ ] Update .env.example with new variables

PHASE 4: Testing
  [ ] Run unit tests
  [ ] Run integration tests
  [ ] Verify <500ms average sync
  [ ] Verify >99% success rate

PHASE 5: Validation
  [ ] Deploy to staging
  [ ] Monitor metrics for 24-48 hours
  [ ] Compare with main branch

PHASE 6: Production
  [ ] Deploy to production
  [ ] Monitor metrics for 1 week
  [ ] Declare success when targets met

================================================================================
QUICK START GUIDE
================================================================================

1. READ (15 min):
   → IPFS_FAST_SYNC_SUMMARY.md

2. UNDERSTAND (30 min):
   → IPFS_SYNC_STRATEGY.md (sections 1-5)

3. IMPLEMENT (4 hours):
   → Copy 4 service files
   → Follow IPFS_INTEGRATION_GUIDE.md
   → Use IPFS_IMPLEMENTATION_CHECKLIST.md to track

4. TEST (4 hours):
   → Run unit tests
   → Run integration tests
   → Verify metrics

5. VALIDATE (24-48 hours):
   → Deploy to staging
   → Monitor metrics

6. DEPLOY (ongoing):
   → Deploy to production
   → Monitor for 1 week

Total Implementation Time: ~2 weeks

================================================================================
SUCCESS CRITERIA
================================================================================

Performance:
  ✓ P95 latency < 2000ms (actual target: <300ms)
  ✓ Average latency < 500ms
  ✓ Cache hit rate > 50%

Reliability:
  ✓ Success rate > 99%
  ✓ Zero hangs/infinite waits
  ✓ DHT fallback working

Operations:
  ✓ Metrics dashboard functional
  ✓ Monitoring alerts configured
  ✓ Team trained on new architecture
  ✓ Documentation complete

================================================================================
TROUBLESHOOTING
================================================================================

Slow IPNS Resolution?
  → Check node latency: curl https://unicity-ipfs1.dyndns.org/api/v0/id
  → Check DNS: dig unicity-ipfs1.dyndns.org
  → Check metrics for bottleneck identification

High Failure Rate?
  → Verify all 5 nodes running: curl https://unicity-ipfs{1-5}.dyndns.org/...
  → Check IPNS records exist: ipfs name resolve /ipns/{name}
  → Check content stored: ipfs cat {cid}

Low Cache Hit Rate?
  → Check TTL configuration (should be 60 seconds)
  → Verify sync happens within TTL window
  → Look at time between consecutive syncs

DHT Fallback Activated?
  → HTTP methods failed (check metrics for why)
  → Fallback to DHT with 1s timeout
  → Review node status + network connectivity

================================================================================
MONITORING COMMANDS
================================================================================

Check Metrics:
  const metrics = getIpfsMetrics();
  console.log(metrics.getSnapshot());

Check Cache Stats:
  const resolver = getIpfsHttpResolver();
  console.log(resolver.getCacheStats());

Force Cache Clear:
  resolver.invalidateIpnsCache();

Get Target Status:
  console.log(metrics.getTargetStatus());

Export Metrics:
  const exported = metrics.export();
  localStorage.setItem('ipfs_metrics', JSON.stringify(exported));

================================================================================
KUBO NODE CHECKLIST
================================================================================

Per Node:
  [ ] HTTP API running on port 9080
  [ ] Gateway running on port 8080
  [ ] WebSocket enabled on port 4002
  [ ] HTTPS reverse proxy (nginx) on port 443
  [ ] Certificate valid and up to date
  [ ] DNS resolving correctly

Verification:
  [ ] curl https://unicity-ipfs1.dyndns.org/api/v0/id (HTTP API)
  [ ] curl https://unicity-ipfs1.dyndns.org/ipfs/{cid} (Gateway)
  [ ] curl -I https://unicity-ipfs1.dyndns.org/ (HTTPS)

================================================================================
EXPECTED METRICS
================================================================================

After Implementation:

Operation Counts (per hour):
  Resolves: 1000+
  Publishes: 50-100
  Fetches: 2000+
  Cache hits: 600+

Latency (ms):
  P50 Resolve: 80
  P95 Resolve: 250
  P99 Resolve: 450

  P50 Publish: 200
  P95 Publish: 400
  P99 Publish: 500

Success Rates:
  HTTP Success: >99%
  Cache Hit Rate: 60%+
  Overall Success: >99.5%

================================================================================
DOCUMENTATION MAP
================================================================================

START HERE:
  README_IPFS_FAST_SYNC.md ← Master reference with all links

THEN READ (In Order):
  1. IPFS_FAST_SYNC_SUMMARY.md (15 min) ← Executive overview
  2. IPFS_SYNC_STRATEGY.md (45 min) ← Detailed design
  3. IPFS_INTEGRATION_GUIDE.md (30 min) ← Implementation

USE WHILE IMPLEMENTING:
  IPFS_IMPLEMENTATION_CHECKLIST.md ← Track progress by phase

================================================================================
KEY DECISIONS EXPLAINED
================================================================================

Why 3-Tier Architecture?
  • Cache: 99% of calls satisfied locally after first sync
  • HTTP: 100-300ms, suitable for UI
  • DHT: Fallback for compatibility, graceful degradation

Why Parallel Multi-Node?
  • Resilient: Even if 2 nodes down, success rate >99%
  • Fast: Fastest node wins (100-300ms typical)
  • Simple: No complex load balancing needed

Why Two HTTP Methods?
  • Gateway Path: Fast (30-100ms), returns content directly
  • Routing API: Reliable (200-300ms), returns sequence number
  • Together: Best of both worlds

Why These Timeouts?
  • HTTP: 5 seconds (reasonable for network ops)
  • Content: 3 seconds (immutable, should be cached)
  • Publish: 5 seconds (multiple nodes, more time needed)
  • DHT: 1 second (fallback only, don't wait long)
  • Cache IPNS: 60 seconds (short, records change during sync)

Why Not Use DHT Primarily?
  • DHT slow: 10-30+ seconds typical
  • Not designed for high-frequency queries
  • Your infrastructure advantage: 5 dedicated nodes
  • HTTP faster + more reliable for known nodes

================================================================================
VERSION HISTORY
================================================================================

2025-12-23: Initial Architecture
  • Complete 3-tier design
  • 4 service implementations
  • 5 comprehensive documentation files
  • Implementation checklist with timeline

================================================================================
QUESTIONS? SEE:
================================================================================

"Why is X needed?"
  → IPFS_SYNC_STRATEGY.md (FAQ section)

"How do I implement X?"
  → IPFS_INTEGRATION_GUIDE.md

"What should I do this week?"
  → IPFS_IMPLEMENTATION_CHECKLIST.md (current phase)

"What's the architecture?"
  → IPFS_FAST_SYNC_SUMMARY.md (sections 2-3)

"Show me metrics"
  → IPFS_INTEGRATION_GUIDE.md (monitoring section)

================================================================================
READY TO START?
================================================================================

1. Open: docs/README_IPFS_FAST_SYNC.md
2. Read: docs/IPFS_FAST_SYNC_SUMMARY.md
3. Copy: src/components/wallet/L3/services/Ipfs*.ts files
4. Integrate: Follow docs/IPFS_INTEGRATION_GUIDE.md
5. Track: Use docs/IPFS_IMPLEMENTATION_CHECKLIST.md

Estimated Effort: 2 weeks
Expected Benefit: 30-100x faster sync

Let's go!

================================================================================
