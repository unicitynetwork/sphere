import{b as Jt,a as Ft,c as q,h as Yt,d as yt,r as Xe,i as Ge,s as Wr,e as Se,f as Jr,j as Qr}from"./index-kNh7CKb3.js";class V extends Error{static name="InvalidParametersError";constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}}class qn extends Error{static name="InvalidPublicKeyError";constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}class Vn extends Error{static name="InvalidPrivateKeyError";constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}}class ic extends Error{static name="InvalidCIDError";constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}class sc extends Error{static name="InvalidMultihashError";constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}class Qt extends Error{static name="UnsupportedKeyTypeError";constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}function ti(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function Ae(e){if(e instanceof Uint8Array&&e.constructor.name==="Uint8Array")return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")}function ei(e){return new TextEncoder().encode(e)}function ni(e){return new TextDecoder().decode(e)}function ri(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var s=e.charAt(i),o=s.charCodeAt(0);if(n[o]!==255)throw new TypeError(s+" is ambiguous");n[o]=i}var c=e.length,a=e.charAt(0),h=Math.log(c)/Math.log(256),w=Math.log(256)/Math.log(c);function S(d){if(d instanceof Uint8Array||(ArrayBuffer.isView(d)?d=new Uint8Array(d.buffer,d.byteOffset,d.byteLength):Array.isArray(d)&&(d=Uint8Array.from(d))),!(d instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(d.length===0)return"";for(var D=0,A=0,y=0,m=d.length;y!==m&&d[y]===0;)y++,D++;for(var E=(m-y)*w+1>>>0,R=new Uint8Array(E);y!==m;){for(var O=d[y],T=0,k=E-1;(O!==0||T<A)&&k!==-1;k--,T++)O+=256*R[k]>>>0,R[k]=O%c>>>0,O=O/c>>>0;if(O!==0)throw new Error("Non-zero carry");A=T,y++}for(var p=E-A;p!==E&&R[p]===0;)p++;for(var b=a.repeat(D);p<E;++p)b+=e.charAt(R[p]);return b}function _(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return new Uint8Array;var D=0;if(d[D]!==" "){for(var A=0,y=0;d[D]===a;)A++,D++;for(var m=(d.length-D)*h+1>>>0,E=new Uint8Array(m);d[D];){var R=n[d.charCodeAt(D)];if(R===255)return;for(var O=0,T=m-1;(R!==0||O<y)&&T!==-1;T--,O++)R+=c*E[T]>>>0,E[T]=R%256>>>0,R=R/256>>>0;if(R!==0)throw new Error("Non-zero carry");y=O,D++}if(d[D]!==" "){for(var k=m-y;k!==m&&E[k]===0;)k++;for(var p=new Uint8Array(A+(m-k)),b=A;k!==m;)p[b++]=E[k++];return p}}}function B(d){var D=_(d);if(D)return D;throw new Error(`Non-${t} character`)}return{encode:S,decodeUnsafe:_,decode:B}}var ii=ri,si=ii;class oi{name;prefix;baseEncode;constructor(t,n,r){this.name=t,this.prefix=n,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class ai{name;prefix;baseDecode;prefixCodePoint;constructor(t,n,r){this.name=t,this.prefix=n;const i=n.codePointAt(0);if(i===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=i,this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return zn(this,t)}}class ci{decoders;constructor(t){this.decoders=t}or(t){return zn(this,t)}decode(t){const n=t[0],r=this.decoders[n];if(r!=null)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function zn(e,t){return new ci({...e.decoders??{[e.prefix]:e},...t.decoders??{[t.prefix]:t}})}class ui{name;prefix;baseEncode;baseDecode;encoder;decoder;constructor(t,n,r,i){this.name=t,this.prefix=n,this.baseEncode=r,this.baseDecode=i,this.encoder=new oi(t,n,r),this.decoder=new ai(t,n,i)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function xe({name:e,prefix:t,encode:n,decode:r}){return new ui(e,t,n,r)}function te({name:e,prefix:t,alphabet:n}){const{encode:r,decode:i}=si(n,e);return xe({prefix:t,name:e,encode:r,decode:s=>Ae(i(s))})}function fi(e,t,n,r){let i=e.length;for(;e[i-1]==="=";)--i;const s=new Uint8Array(i*n/8|0);let o=0,c=0,a=0;for(let h=0;h<i;++h){const w=t[e[h]];if(w===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<n|w,o+=n,o>=8&&(o-=8,s[a++]=255&c>>o)}if(o>=n||(255&c<<8-o)!==0)throw new SyntaxError("Unexpected end of data");return s}function li(e,t,n){const r=t[t.length-1]==="=",i=(1<<n)-1;let s="",o=0,c=0;for(let a=0;a<e.length;++a)for(c=c<<8|e[a],o+=8;o>n;)o-=n,s+=t[i&c>>o];if(o!==0&&(s+=t[i&c<<n-o]),r)for(;(s.length*n&7)!==0;)s+="=";return s}function hi(e){const t={};for(let n=0;n<e.length;++n)t[e[n]]=n;return t}function nt({name:e,prefix:t,bitsPerChar:n,alphabet:r}){const i=hi(r);return xe({prefix:t,name:e,encode(s){return li(s,r,n)},decode(s){return fi(s,i,n,e)}})}const ft=te({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),di=te({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),yi=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ft,base58flickr:di},Symbol.toStringTag,{value:"Module"})),zt=nt({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),wi=nt({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),bi=nt({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),gi=nt({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),pi=nt({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),mi=nt({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ei=nt({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Si=nt({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Ai=nt({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),xi=Object.freeze(Object.defineProperty({__proto__:null,base32:zt,base32hex:pi,base32hexpad:Ei,base32hexpadupper:Si,base32hexupper:mi,base32pad:bi,base32padupper:gi,base32upper:wi,base32z:Ai},Symbol.toStringTag,{value:"Module"})),ue=te({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),vi=te({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Bi=Object.freeze(Object.defineProperty({__proto__:null,base36:ue,base36upper:vi},Symbol.toStringTag,{value:"Module"}));var Ii=Zn,pn=128,_i=-128,Ki=Math.pow(2,31);function Zn(e,t,n){t=t||[],n=n||0;for(var r=n;e>=Ki;)t[n++]=e&255|pn,e/=128;for(;e&_i;)t[n++]=e&255|pn,e>>>=7;return t[n]=e|0,Zn.bytes=n-r+1,t}var Ri=Me,Ui=128,mn=127;function Me(e,r){var n=0,r=r||0,i=0,s=r,o,c=e.length;do{if(s>=c)throw Me.bytes=0,new RangeError("Could not decode varint");o=e[s++],n+=i<28?(o&mn)<<i:(o&mn)*Math.pow(2,i),i+=7}while(o>=Ui);return Me.bytes=s-r,n}var Di=Math.pow(2,7),Li=Math.pow(2,14),Ci=Math.pow(2,21),Ni=Math.pow(2,28),Oi=Math.pow(2,35),Ti=Math.pow(2,42),ki=Math.pow(2,49),Mi=Math.pow(2,56),Pi=Math.pow(2,63),$i=function(e){return e<Di?1:e<Li?2:e<Ci?3:e<Ni?4:e<Oi?5:e<Ti?6:e<ki?7:e<Mi?8:e<Pi?9:10},qi={encode:Ii,decode:Ri,encodingLength:$i},he=qi;function Pe(e,t=0){return[he.decode(e,t),he.decode.bytes]}function de(e,t,n=0){return he.encode(e,t,n),t}function ye(e){return he.encodingLength(e)}function Mt(e,t){const n=t.byteLength,r=ye(e),i=r+ye(n),s=new Uint8Array(i+n);return de(e,s,0),de(n,s,r),s.set(t,i),new We(e,n,t,s)}function Vi(e){const t=Ae(e),[n,r]=Pe(t),[i,s]=Pe(t.subarray(r)),o=t.subarray(r+s);if(o.byteLength!==i)throw new Error("Incorrect length");return new We(n,i,o,t)}function zi(e,t){if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&ti(e.bytes,n.bytes)}}class We{code;size;digest;bytes;constructor(t,n,r,i){this.code=t,this.size=n,this.digest=r,this.bytes=i}}function En(e,t){const{bytes:n,version:r}=e;return r===0?ji(n,$e(e),t??ft.encoder):Fi(n,$e(e),t??zt.encoder)}const Sn=new WeakMap;function $e(e){const t=Sn.get(e);if(t==null){const n=new Map;return Sn.set(e,n),n}return t}class X{code;version;multihash;bytes;"/";constructor(t,n,r,i){this.code=n,this.version=t,this.multihash=r,this.bytes=i,this["/"]=i}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:n}=this;if(t!==Pt)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(n.code!==Yi)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return X.createV0(n)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:n}=this.multihash,r=Mt(t,n);return X.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return X.equals(this,t)}static equals(t,n){const r=n;return r!=null&&t.code===r.code&&t.version===r.version&&zi(t.multihash,r.multihash)}toString(t){return En(this,t)}toJSON(){return{"/":En(this)}}link(){return this}[Symbol.toStringTag]="CID";[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const n=t;if(n instanceof X)return n;if(n["/"]!=null&&n["/"]===n.bytes||n.asCID===n){const{version:r,code:i,multihash:s,bytes:o}=n;return new X(r,i,s,o??An(r,i,s.bytes))}else if(n[Hi]===!0){const{version:r,multihash:i,code:s}=n,o=Vi(i);return X.create(r,s,o)}else return null}static create(t,n,r){if(typeof n!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(n!==Pt)throw new Error(`Version 0 CID must use dag-pb (code: ${Pt}) block encoding`);return new X(t,n,r,r.bytes)}case 1:{const i=An(t,n,r.bytes);return new X(t,n,r,i)}default:throw new Error("Invalid version")}}static createV0(t){return X.create(0,Pt,t)}static createV1(t,n){return X.create(1,t,n)}static decode(t){const[n,r]=X.decodeFirst(t);if(r.length!==0)throw new Error("Incorrect length");return n}static decodeFirst(t){const n=X.inspectBytes(t),r=n.size-n.multihashSize,i=Ae(t.subarray(r,r+n.multihashSize));if(i.byteLength!==n.multihashSize)throw new Error("Incorrect length");const s=i.subarray(n.multihashSize-n.digestSize),o=new We(n.multihashCode,n.digestSize,s,i);return[n.version===0?X.createV0(o):X.createV1(n.codec,o),t.subarray(n.size)]}static inspectBytes(t){let n=0;const r=()=>{const[S,_]=Pe(t.subarray(n));return n+=_,S};let i=r(),s=Pt;if(i===18?(i=0,n=0):s=r(),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const o=n,c=r(),a=r(),h=n+a,w=h-o;return{version:i,codec:s,multihashCode:c,digestSize:a,multihashSize:w,size:h}}static parse(t,n){const[r,i]=Zi(t,n),s=X.decode(i);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return $e(s).set(r,t),s}}function Zi(e,t){switch(e[0]){case"Q":{const n=t??ft;return[ft.prefix,n.decode(`${ft.prefix}${e}`)]}case ft.prefix:{const n=t??ft;return[ft.prefix,n.decode(e)]}case zt.prefix:{const n=t??zt;return[zt.prefix,n.decode(e)]}case ue.prefix:{const n=t??ue;return[ue.prefix,n.decode(e)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}}}function ji(e,t,n){const{prefix:r}=n;if(r!==ft.prefix)throw Error(`Cannot string encode V0 in ${n.name} encoding`);const i=t.get(r);if(i==null){const s=n.encode(e).slice(1);return t.set(r,s),s}else return i}function Fi(e,t,n){const{prefix:r}=n,i=t.get(r);if(i==null){const s=n.encode(e);return t.set(r,s),s}else return i}const Pt=112,Yi=18;function An(e,t,n){const r=ye(e),i=r+ye(t),s=new Uint8Array(i+n.byteLength);return de(e,s,0),de(t,s,r),s.set(n,i),s}const Hi=Symbol.for("@ipld/js-cid/CID"),jn=0,Xi="identity",Fn=Ae;function Gi(e,t){if(t?.truncate!=null&&t.truncate!==e.byteLength){if(t.truncate<0||t.truncate>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,t.truncate)}return Mt(jn,Fn(e))}const Je={code:jn,name:Xi,encode:Fn,digest:Gi};function wt(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0}function mt(e=0){return new Uint8Array(e)}function Rt(e=0){return new Uint8Array(e)}function Tt(e,t){t==null&&(t=e.reduce((i,s)=>i+s.length,0));const n=Rt(t);let r=0;for(const i of e)n.set(i,r),r+=i.length;return n}const Yn=Symbol.for("@achingbrain/uint8arraylist");function xn(e,t){if(t==null||t<0)throw new RangeError("index is out of bounds");let n=0;for(const r of e){const i=n+r.byteLength;if(t<i)return{buf:r,index:t-n};n=i}throw new RangeError("index is out of bounds")}function ie(e){return!!e?.[Yn]}class at{bufs;length;[Yn]=!0;constructor(...t){this.bufs=[],this.length=0,t.length>0&&this.appendAll(t)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...t){this.appendAll(t)}appendAll(t){let n=0;for(const r of t)if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.push(r);else if(ie(r))n+=r.byteLength,this.bufs.push(...r.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}prepend(...t){this.prependAll(t)}prependAll(t){let n=0;for(const r of t.reverse())if(r instanceof Uint8Array)n+=r.byteLength,this.bufs.unshift(r);else if(ie(r))n+=r.byteLength,this.bufs.unshift(...r.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=n}get(t){const n=xn(this.bufs,t);return n.buf[n.index]}set(t,n){const r=xn(this.bufs,t);r.buf[r.index]=n}write(t,n=0){if(t instanceof Uint8Array)for(let r=0;r<t.length;r++)this.set(n+r,t[r]);else if(ie(t))for(let r=0;r<t.length;r++)this.set(n+r,t.get(r));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(t){if(t=Math.trunc(t),!(Number.isNaN(t)||t<=0)){if(t===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(t>=this.bufs[0].byteLength)t-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(t),this.length-=t;break}}}slice(t,n){const{bufs:r,length:i}=this._subList(t,n);return Tt(r,i)}subarray(t,n){const{bufs:r,length:i}=this._subList(t,n);return r.length===1?r[0]:Tt(r,i)}sublist(t,n){const{bufs:r,length:i}=this._subList(t,n),s=new at;return s.length=i,s.bufs=[...r],s}_subList(t,n){if(t=t??0,n=n??this.length,t<0&&(t=this.length+t),n<0&&(n=this.length+n),t<0||n>this.length)throw new RangeError("index is out of bounds");if(t===n)return{bufs:[],length:0};if(t===0&&n===this.length)return{bufs:this.bufs,length:this.length};const r=[];let i=0;for(let s=0;s<this.bufs.length;s++){const o=this.bufs[s],c=i,a=c+o.byteLength;if(i=a,t>=a)continue;const h=t>=c&&t<a,w=n>c&&n<=a;if(h&&w){if(t===c&&n===a){r.push(o);break}const S=t-c;r.push(o.subarray(S,S+(n-t)));break}if(h){if(t===0){r.push(o);continue}r.push(o.subarray(t-c));continue}if(w){if(n===a){r.push(o);break}r.push(o.subarray(0,n-c));break}r.push(o)}return{bufs:r,length:n-t}}indexOf(t,n=0){if(!ie(t)&&!(t instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const r=t instanceof Uint8Array?t:t.subarray();if(n=Number(n??0),isNaN(n)&&(n=0),n<0&&(n=this.length+n),n<0&&(n=0),t.length===0)return n>this.length?this.length:n;const i=r.byteLength;if(i===0)throw new TypeError("search must be at least 1 byte long");const s=256,o=new Int32Array(s);for(let S=0;S<s;S++)o[S]=-1;for(let S=0;S<i;S++)o[r[S]]=S;const c=o,a=this.byteLength-r.byteLength,h=r.byteLength-1;let w;for(let S=n;S<=a;S+=w){w=0;for(let _=h;_>=0;_--){const B=this.get(S+_);if(r[_]!==B){w=Math.max(1,_-c[B]);break}}if(w===0)return S}return-1}getInt8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getInt8(0)}setInt8(t,n){const r=Rt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setInt8(0,n),this.write(r,t)}getInt16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt16(0,n)}setInt16(t,n,r){const i=mt(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt16(0,n,r),this.write(i,t)}getInt32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getInt32(0,n)}setInt32(t,n,r){const i=mt(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setInt32(0,n,r),this.write(i,t)}getBigInt64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigInt64(0,n)}setBigInt64(t,n,r){const i=mt(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigInt64(0,n,r),this.write(i,t)}getUint8(t){const n=this.subarray(t,t+1);return new DataView(n.buffer,n.byteOffset,n.byteLength).getUint8(0)}setUint8(t,n){const r=Rt(1);new DataView(r.buffer,r.byteOffset,r.byteLength).setUint8(0,n),this.write(r,t)}getUint16(t,n){const r=this.subarray(t,t+2);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint16(0,n)}setUint16(t,n,r){const i=mt(2);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint16(0,n,r),this.write(i,t)}getUint32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getUint32(0,n)}setUint32(t,n,r){const i=mt(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,n,r),this.write(i,t)}getBigUint64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getBigUint64(0,n)}setBigUint64(t,n,r){const i=mt(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setBigUint64(0,n,r),this.write(i,t)}getFloat32(t,n){const r=this.subarray(t,t+4);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat32(0,n)}setFloat32(t,n,r){const i=mt(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat32(0,n,r),this.write(i,t)}getFloat64(t,n){const r=this.subarray(t,t+8);return new DataView(r.buffer,r.byteOffset,r.byteLength).getFloat64(0,n)}setFloat64(t,n,r){const i=mt(8);new DataView(i.buffer,i.byteOffset,i.byteLength).setFloat64(0,n,r),this.write(i,t)}equals(t){if(t==null||!(t instanceof at)||t.bufs.length!==this.bufs.length)return!1;for(let n=0;n<this.bufs.length;n++)if(!wt(this.bufs[n],t.bufs[n]))return!1;return!0}static fromUint8Arrays(t,n){const r=new at;return r.bufs=t,n==null&&(n=t.reduce((i,s)=>i+s.byteLength,0)),r.length=n,r}}const Wi=te({prefix:"9",name:"base10",alphabet:"0123456789"}),Ji=Object.freeze(Object.defineProperty({__proto__:null,base10:Wi},Symbol.toStringTag,{value:"Module"})),Qi=nt({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),ts=nt({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),es=Object.freeze(Object.defineProperty({__proto__:null,base16:Qi,base16upper:ts},Symbol.toStringTag,{value:"Module"})),ns=nt({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),rs=Object.freeze(Object.defineProperty({__proto__:null,base2:ns},Symbol.toStringTag,{value:"Module"})),Hn=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),is=Hn.reduce((e,t,n)=>(e[n]=t,e),[]),ss=Hn.reduce((e,t,n)=>{const r=t.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${t}`);return e[r]=n,e},[]);function os(e){return e.reduce((t,n)=>(t+=is[n],t),"")}function as(e){const t=[];for(const n of e){const r=n.codePointAt(0);if(r==null)throw new Error(`Invalid character: ${n}`);const i=ss[r];if(i==null)throw new Error(`Non-base256emoji character: ${n}`);t.push(i)}return new Uint8Array(t)}const cs=xe({prefix:"ðŸš€",name:"base256emoji",encode:os,decode:as}),us=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:cs},Symbol.toStringTag,{value:"Module"})),fs=nt({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),ls=nt({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),hs=nt({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ds=nt({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),ys=Object.freeze(Object.defineProperty({__proto__:null,base64:fs,base64pad:ls,base64url:hs,base64urlpad:ds},Symbol.toStringTag,{value:"Module"})),ws=nt({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),bs=Object.freeze(Object.defineProperty({__proto__:null,base8:ws},Symbol.toStringTag,{value:"Module"})),gs=xe({prefix:"\0",name:"identity",encode:e=>ni(e),decode:e=>ei(e)}),ps=Object.freeze(Object.defineProperty({__proto__:null,identity:gs},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const ms=20;function Es({name:e,code:t,encode:n,minDigestLength:r,maxDigestLength:i}){return new Ss(e,t,n,r,i)}class Ss{name;code;encode;minDigestLength;maxDigestLength;constructor(t,n,r,i,s){this.name=t,this.code=n,this.encode=r,this.minDigestLength=i??ms,this.maxDigestLength=s}digest(t,n){if(n?.truncate!=null){if(n.truncate<this.minDigestLength)throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);if(this.maxDigestLength!=null&&n.truncate>this.maxDigestLength)throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)}if(t instanceof Uint8Array){const r=this.encode(t);return r instanceof Uint8Array?vn(r,this.code,n?.truncate):r.then(i=>vn(i,this.code,n?.truncate))}else throw Error("Unknown type, must be binary type")}}function vn(e,t,n){if(n!=null&&n!==e.byteLength){if(n>e.byteLength)throw new Error(`Invalid truncate option, must be less than or equal to ${e.byteLength}`);e=e.subarray(0,n)}return Mt(t,e)}function As(e){return async t=>new Uint8Array(await crypto.subtle.digest(e,t))}const Xn=Es({name:"sha2-256",code:18,encode:As("SHA-256")}),Bn={...ps,...rs,...bs,...Ji,...es,...xi,...Bi,...yi,...ys,...us};function Gn(e,t,n,r){return{name:e,prefix:t,encoder:{name:e,prefix:t,encode:n},decoder:{decode:r}}}const In=Gn("utf8","u",e=>"u"+new TextDecoder("utf8").decode(e),e=>new TextEncoder().encode(e.substring(1))),Ue=Gn("ascii","a",e=>{let t="a";for(let n=0;n<e.length;n++)t+=String.fromCharCode(e[n]);return t},e=>{e=e.substring(1);const t=Rt(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}),Wn={utf8:In,"utf-8":In,hex:Bn.base16,latin1:Ue,ascii:Ue,binary:Ue,...Bn};function W(e,t="utf8"){const n=Wn[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.decoder.decode(`${n.prefix}${e}`)}function $(e,t="utf8"){const n=Wn[t];if(n==null)throw new Error(`Unsupported encoding "${t}"`);return n.encoder.encode(e).substring(1)}const xs=parseInt("11111",2),qe=parseInt("10000000",2),vs=parseInt("01111111",2),_n={0:$t,1:$t,2:Bs,3:Ks,4:Rs,5:_s,6:Is,16:$t,22:$t,48:$t};function Bt(e,t={offset:0}){const n=e[t.offset]&xs;if(t.offset++,_n[n]!=null)return _n[n](e,t);throw new Error("No decoder for tag "+n)}function ee(e,t){let n=0;if((e[t.offset]&qe)===qe){const r=e[t.offset]&vs;let i="0x";t.offset++;for(let s=0;s<r;s++,t.offset++)i+=e[t.offset].toString(16).padStart(2,"0");n=parseInt(i,16)}else n=e[t.offset],t.offset++;return n}function $t(e,t){ee(e,t);const n=[];for(;!(t.offset>=e.byteLength);){const r=Bt(e,t);if(r===null)break;n.push(r)}return n}function Bs(e,t){const n=ee(e,t),r=t.offset,i=t.offset+n,s=[];for(let o=r;o<i;o++)o===r&&e[o]===0||s.push(e[o]);return t.offset+=n,Uint8Array.from(s)}function Is(e,t){const n=ee(e,t),r=t.offset+n,i=e[t.offset];t.offset++;let s=0,o=0;i<40?(s=0,o=i):i<80?(s=1,o=i-40):(s=2,o=i-80);let c=`${s}.${o}`,a=[];for(;t.offset<r;){const h=e[t.offset];if(t.offset++,a.push(h&127),h<128){a.reverse();let w=0;for(let S=0;S<a.length;S++)w+=a[S]<<S*7;c+=`.${w}`,a=[]}}return c}function _s(e,t){return t.offset++,null}function Ks(e,t){const n=ee(e,t),r=e[t.offset];t.offset++;const i=e.subarray(t.offset,t.offset+n-1);if(t.offset+=n,r!==0)throw new Error("Unused bits in bit string is unimplemented");return i}function Rs(e,t){const n=ee(e,t),r=e.subarray(t.offset,t.offset+n);return t.offset+=n,r}function Us(e){let t=e.toString(16);t.length%2===1&&(t="0"+t);const n=new at;for(let r=0;r<t.length;r+=2)n.append(Uint8Array.from([parseInt(`${t[r]}${t[r+1]}`,16)]));return n}function ve(e){if(e.byteLength<128)return Uint8Array.from([e.byteLength]);const t=Us(e.byteLength);return new at(Uint8Array.from([t.byteLength|qe]),t)}function ut(e){const t=new at,n=128;return(e.subarray()[0]&n)===n&&t.append(Uint8Array.from([0])),t.append(e),new at(Uint8Array.from([2]),ve(t),t)}function Qe(e){const t=Uint8Array.from([0]),n=new at(t,e);return new at(Uint8Array.from([3]),ve(n),n)}function Ds(e){return new at(Uint8Array.from([4]),ve(e),e)}function gt(e,t=48){const n=new at;for(const r of e)n.append(r);return new at(Uint8Array.from([t]),ve(n),n)}const Jn="1.2.840.10045.3.1.7",Qn="1.3.132.0.34",tr="1.3.132.0.35";async function Ls(e="P-256"){const t=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:e},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",t.publicKey),privateKey:await crypto.subtle.exportKey("jwk",t.privateKey)}}async function Cs(e,t,n){const r=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["sign"]);n?.signal?.throwIfAborted();const i=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r,t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}async function Ns(e,t,n,r){const i=await crypto.subtle.importKey("jwk",e,{name:"ECDSA",namedCurve:e.crv??"P-256"},!1,["verify"]);r?.signal?.throwIfAborted();const s=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,t,n.subarray());return r?.signal?.throwIfAborted(),s}const Os=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),Ts=Uint8Array.from([6,5,43,129,4,0,34]),ks=Uint8Array.from([6,5,43,129,4,0,35]),er={ext:!0,kty:"EC",crv:"P-256"},nr={ext:!0,kty:"EC",crv:"P-384"},rr={ext:!0,kty:"EC",crv:"P-521"},Dt=32,Lt=48,Ct=66;function Ms(e){const t=Bt(e);return ir(t)}function ir(e){const t=e[1],n=$(t,"base64url"),r=e[2][1][0],i=1;let s,o;if(t.byteLength===Dt)return s=$(r.subarray(i,i+Dt),"base64url"),o=$(r.subarray(i+Dt),"base64url"),new Zt({...er,key_ops:["sign"],d:n,x:s,y:o});if(t.byteLength===Lt)return s=$(r.subarray(i,i+Lt),"base64url"),o=$(r.subarray(i+Lt),"base64url"),new Zt({...nr,key_ops:["sign"],d:n,x:s,y:o});if(t.byteLength===Ct)return s=$(r.subarray(i,i+Ct),"base64url"),o=$(r.subarray(i+Ct),"base64url"),new Zt({...rr,key_ops:["sign"],d:n,x:s,y:o});throw new V(`Private key length was wrong length, got ${t.byteLength}, expected 32, 48 or 66`)}function sr(e){const t=Bt(e);return or(t)}function or(e){const t=e[1][1][0],n=1;let r,i;if(t.byteLength===Dt*2+1)return r=$(t.subarray(n,n+Dt),"base64url"),i=$(t.subarray(n+Dt),"base64url"),new fe({...er,key_ops:["verify"],x:r,y:i});if(t.byteLength===Lt*2+1)return r=$(t.subarray(n,n+Lt),"base64url"),i=$(t.subarray(n+Lt),"base64url"),new fe({...nr,key_ops:["verify"],x:r,y:i});if(t.byteLength===Ct*2+1)return r=$(t.subarray(n,n+Ct),"base64url"),i=$(t.subarray(n+Ct),"base64url"),new fe({...rr,key_ops:["verify"],x:r,y:i});throw new V(`coordinates were wrong length, got ${t.byteLength}, expected 65, 97 or 133`)}function Ps(e){return gt([ut(Uint8Array.from([1])),Ds(W(e.d??"","base64url")),gt([ar(e.crv)],160),gt([Qe(new at(Uint8Array.from([4]),W(e.x??"","base64url"),W(e.y??"","base64url")))],161)]).subarray()}function $s(e){return gt([ut(Uint8Array.from([1])),gt([ar(e.crv)],160),gt([Qe(new at(Uint8Array.from([4]),W(e.x??"","base64url"),W(e.y??"","base64url")))],161)]).subarray()}function ar(e){if(e==="P-256")return Os;if(e==="P-384")return Ts;if(e==="P-521")return ks;throw new V(`Invalid curve ${e}`)}async function qs(e="P-256"){const t=await Ls(e);return new Zt(t.privateKey)}class fe{type="ECDSA";jwk;_raw;constructor(t){this.jwk=t}get raw(){return this._raw==null&&(this._raw=$s(this.jwk)),this._raw}toMultihash(){return Je.digest(Re(this))}toCID(){return X.createV1(114,this.toMultihash())}toString(){return ft.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}async verify(t,n,r){return Ns(this.jwk,n,t,r)}}class Zt{type="ECDSA";jwk;publicKey;_raw;constructor(t){this.jwk=t,this.publicKey=new fe({crv:t.crv,ext:t.ext,key_ops:["verify"],kty:"EC",x:t.x,y:t.y})}get raw(){return this._raw==null&&(this._raw=Ps(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}async sign(t,n){return Cs(this.jwk,t,n)}}const tn=BigInt(0),Ve=BigInt(1);function Ut(e,t=""){if(typeof e!="boolean"){const n=t&&`"${t}" `;throw new Error(n+"expected boolean, got type="+typeof e)}return e}function cr(e){if(typeof e=="bigint"){if(!le(e))throw new Error("positive bigint expected, got "+e)}else Ft(e);return e}function se(e){const t=cr(e).toString(16);return t.length&1?"0"+t:t}function ur(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?tn:BigInt("0x"+e)}function Be(e){return ur(Jt(e))}function Ht(e){return ur(Jt(ze(q(e)).reverse()))}function en(e,t){Ft(t),e=cr(e);const n=Yt(e.toString(16).padStart(t*2,"0"));if(n.length!==t)throw new Error("number too large");return n}function fr(e,t){return en(e,t).reverse()}function ze(e){return Uint8Array.from(e)}const le=e=>typeof e=="bigint"&&tn<=e;function Vs(e,t,n){return le(e)&&le(t)&&le(n)&&t<=e&&e<n}function Ze(e,t,n,r){if(!Vs(t,n,r))throw new Error("expected valid "+e+": "+n+" <= n < "+r+", got "+t)}function zs(e){let t;for(t=0;e>tn;e>>=Ve,t+=1);return t}const nn=e=>(Ve<<BigInt(e))-Ve;function Zs(e,t,n){if(Ft(e,"hashLen"),Ft(t,"qByteLen"),typeof n!="function")throw new Error("hmacFn must be a function");const r=A=>new Uint8Array(A),i=Uint8Array.of(),s=Uint8Array.of(0),o=Uint8Array.of(1),c=1e3;let a=r(e),h=r(e),w=0;const S=()=>{a.fill(1),h.fill(0),w=0},_=(...A)=>n(h,yt(a,...A)),B=(A=i)=>{h=_(s,A),a=_(),A.length!==0&&(h=_(o,A),a=_())},d=()=>{if(w++>=c)throw new Error("drbg: tried max amount of iterations");let A=0;const y=[];for(;A<t;){a=_();const m=a.slice();y.push(m),A+=a.length}return yt(...y)};return(A,y)=>{S(),B(A);let m;for(;!(m=y(d()));)B();return S(),m}}function ne(e,t={},n={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(s,o,c){const a=e[s];if(c&&a===void 0)return;const h=typeof a;if(h!==o||a===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${h}`)}const i=(s,o)=>Object.entries(s).forEach(([c,a])=>r(c,a,o));i(t,!1),i(n,!0)}function we(e){const t=new WeakMap;return(n,...r)=>{const i=t.get(n);if(i!==void 0)return i;const s=e(n,...r);return t.set(n,s),s}}const ct=BigInt(0),et=BigInt(1),It=BigInt(2),lr=BigInt(3),hr=BigInt(4),dr=BigInt(5),js=BigInt(7),yr=BigInt(8),Fs=BigInt(9),wr=BigInt(16);function G(e,t){const n=e%t;return n>=ct?n:t+n}function H(e,t,n){let r=e;for(;t-- >ct;)r*=r,r%=n;return r}function Kn(e,t){if(e===ct)throw new Error("invert: expected non-zero number");if(t<=ct)throw new Error("invert: expected positive modulus, got "+t);let n=G(e,t),r=t,i=ct,s=et;for(;n!==ct;){const c=r/n,a=r%n,h=i-s*c;r=n,n=a,i=s,s=h}if(r!==et)throw new Error("invert: does not exist");return G(i,t)}function rn(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function br(e,t){const n=(e.ORDER+et)/hr,r=e.pow(t,n);return rn(e,r,t),r}function Ys(e,t){const n=(e.ORDER-dr)/yr,r=e.mul(t,It),i=e.pow(r,n),s=e.mul(t,i),o=e.mul(e.mul(s,It),i),c=e.mul(s,e.sub(o,e.ONE));return rn(e,c,t),c}function Hs(e){const t=Ie(e),n=gr(e),r=n(t,t.neg(t.ONE)),i=n(t,r),s=n(t,t.neg(r)),o=(e+js)/wr;return(c,a)=>{let h=c.pow(a,o),w=c.mul(h,r);const S=c.mul(h,i),_=c.mul(h,s),B=c.eql(c.sqr(w),a),d=c.eql(c.sqr(S),a);h=c.cmov(h,w,B),w=c.cmov(_,S,d);const D=c.eql(c.sqr(w),a),A=c.cmov(h,w,D);return rn(c,A,a),A}}function gr(e){if(e<lr)throw new Error("sqrt is not defined for small field");let t=e-et,n=0;for(;t%It===ct;)t/=It,n++;let r=It;const i=Ie(e);for(;Rn(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return br;let s=i.pow(r,t);const o=(t+et)/It;return function(a,h){if(a.is0(h))return h;if(Rn(a,h)!==1)throw new Error("Cannot find square root");let w=n,S=a.mul(a.ONE,s),_=a.pow(h,t),B=a.pow(h,o);for(;!a.eql(_,a.ONE);){if(a.is0(_))return a.ZERO;let d=1,D=a.sqr(_);for(;!a.eql(D,a.ONE);)if(d++,D=a.sqr(D),d===w)throw new Error("Cannot find square root");const A=et<<BigInt(w-d-1),y=a.pow(S,A);w=d,S=a.sqr(y),_=a.mul(_,S),B=a.mul(B,y)}return B}}function Xs(e){return e%hr===lr?br:e%yr===dr?Ys:e%wr===Fs?Hs(e):gr(e)}const Gs=(e,t)=>(G(e,t)&et)===et,Ws=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Js(e){const t={ORDER:"bigint",BYTES:"number",BITS:"number"},n=Ws.reduce((r,i)=>(r[i]="function",r),t);return ne(e,n),e}function Qs(e,t,n){if(n<ct)throw new Error("invalid exponent, negatives unsupported");if(n===ct)return e.ONE;if(n===et)return t;let r=e.ONE,i=t;for(;n>ct;)n&et&&(r=e.mul(r,i)),i=e.sqr(i),n>>=et;return r}function pr(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),i=t.reduce((o,c,a)=>e.is0(c)?o:(r[a]=o,e.mul(o,c)),e.ONE),s=e.inv(i);return t.reduceRight((o,c,a)=>e.is0(c)?o:(r[a]=e.mul(o,r[a]),e.mul(o,c)),s),r}function Rn(e,t){const n=(e.ORDER-et)/It,r=e.pow(t,n),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function to(e,t){t!==void 0&&Ft(t);const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}class eo{ORDER;BITS;BYTES;isLE;ZERO=ct;ONE=et;_lengths;_sqrt;_mod;constructor(t,n={}){if(t<=ct)throw new Error("invalid field: expected ORDER > 0, got "+t);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));const{nBitLength:i,nByteLength:s}=to(t,r);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=i,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return G(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return ct<=t&&t<this.ORDER}is0(t){return t===ct}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&et)===et}neg(t){return G(-t,this.ORDER)}eql(t,n){return t===n}sqr(t){return G(t*t,this.ORDER)}add(t,n){return G(t+n,this.ORDER)}sub(t,n){return G(t-n,this.ORDER)}mul(t,n){return G(t*n,this.ORDER)}pow(t,n){return Qs(this,t,n)}div(t,n){return G(t*Kn(n,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,n){return t+n}subN(t,n){return t-n}mulN(t,n){return t*n}inv(t){return Kn(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Xs(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?fr(t,this.BYTES):en(t,this.BYTES)}fromBytes(t,n=!1){q(t);const{_lengths:r,BYTES:i,isLE:s,ORDER:o,_mod:c}=this;if(r){if(!r.includes(t.length)||t.length>i)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);const h=new Uint8Array(i);h.set(t,s?0:h.length-t.length),t=h}if(t.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+t.length);let a=s?Ht(t):Be(t);if(c&&(a=G(a,o)),!n&&!this.isValid(a))throw new Error("invalid field element: outside of range 0..ORDER");return a}invertBatch(t){return pr(this,t)}cmov(t,n,r){return r?n:t}}function Ie(e,t={}){return new eo(e,t)}function mr(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Er(e){const t=mr(e);return t+Math.ceil(t/2)}function no(e,t,n=!1){q(e);const r=e.length,i=mr(t),s=Er(t);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const o=n?Ht(e):Be(e),c=G(o,t-et)+et;return n?fr(c,i):en(c,i)}const kt=BigInt(0),_t=BigInt(1);function be(e,t){const n=t.negate();return e?n:t}function jt(e,t){const n=pr(e.Fp,t.map(r=>r.Z));return t.map((r,i)=>e.fromAffine(r.toAffine(n[i])))}function Sr(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function De(e,t){Sr(e,t);const n=Math.ceil(t/e)+1,r=2**(e-1),i=2**e,s=nn(e),o=BigInt(e);return{windows:n,windowSize:r,mask:s,maxNumber:i,shiftBy:o}}function Un(e,t,n){const{windowSize:r,mask:i,maxNumber:s,shiftBy:o}=n;let c=Number(e&i),a=e>>o;c>r&&(c-=s,a+=_t);const h=t*r,w=h+Math.abs(c)-1,S=c===0,_=c<0,B=t%2!==0;return{nextN:a,offset:w,isZero:S,isNeg:_,isNegF:B,offsetF:h}}const Le=new WeakMap,Ar=new WeakMap;function Ce(e){return Ar.get(e)||1}function Dn(e){if(e!==kt)throw new Error("invalid wNAF")}class xr{BASE;ZERO;Fn;bits;constructor(t,n){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=n}_unsafeLadder(t,n,r=this.ZERO){let i=t;for(;n>kt;)n&_t&&(r=r.add(i)),i=i.double(),n>>=_t;return r}precomputeWindow(t,n){const{windows:r,windowSize:i}=De(n,this.bits),s=[];let o=t,c=o;for(let a=0;a<r;a++){c=o,s.push(c);for(let h=1;h<i;h++)c=c.add(o),s.push(c);o=c.double()}return s}wNAF(t,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let i=this.ZERO,s=this.BASE;const o=De(t,this.bits);for(let c=0;c<o.windows;c++){const{nextN:a,offset:h,isZero:w,isNeg:S,isNegF:_,offsetF:B}=Un(r,c,o);r=a,w?s=s.add(be(_,n[B])):i=i.add(be(S,n[h]))}return Dn(r),{p:i,f:s}}wNAFUnsafe(t,n,r,i=this.ZERO){const s=De(t,this.bits);for(let o=0;o<s.windows&&r!==kt;o++){const{nextN:c,offset:a,isZero:h,isNeg:w}=Un(r,o,s);if(r=c,!h){const S=n[a];i=i.add(w?S.negate():S)}}return Dn(r),i}getPrecomputes(t,n,r){let i=Le.get(n);return i||(i=this.precomputeWindow(n,t),t!==1&&(typeof r=="function"&&(i=r(i)),Le.set(n,i))),i}cached(t,n,r){const i=Ce(t);return this.wNAF(i,this.getPrecomputes(i,t,r),n)}unsafe(t,n,r,i){const s=Ce(t);return s===1?this._unsafeLadder(t,n,i):this.wNAFUnsafe(s,this.getPrecomputes(s,t,r),n,i)}createCache(t,n){Sr(n,this.bits),Ar.set(t,n),Le.delete(t)}hasCache(t){return Ce(t)!==1}}function ro(e,t,n,r){let i=t,s=e.ZERO,o=e.ZERO;for(;n>kt||r>kt;)n&_t&&(s=s.add(i)),r&_t&&(o=o.add(i)),i=i.double(),n>>=_t,r>>=_t;return{p1:s,p2:o}}function Ln(e,t,n){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Js(t),t}else return Ie(e,{isLE:n})}function vr(e,t,n={},r){if(r===void 0&&(r=e==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${e} CURVE object`);for(const a of["p","n","h"]){const h=t[a];if(!(typeof h=="bigint"&&h>kt))throw new Error(`CURVE.${a} must be positive bigint`)}const i=Ln(t.p,n.Fp,r),s=Ln(t.n,n.Fn,r),c=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const a of c)if(!i.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:i,Fn:s}}function Br(e,t){return function(r){const i=e(r);return{secretKey:i,publicKey:t(i)}}}const Et=BigInt(0),Q=BigInt(1),Ne=BigInt(2),io=BigInt(8);function so(e,t,n,r){const i=e.sqr(n),s=e.sqr(r),o=e.add(e.mul(t.a,i),s),c=e.add(e.ONE,e.mul(t.d,e.mul(i,s)));return e.eql(o,c)}function oo(e,t={}){const n=vr("edwards",e,t,t.FpFnLE),{Fp:r,Fn:i}=n;let s=n.CURVE;const{h:o}=s;ne(t,{},{uvRatio:"function"});const c=Ne<<BigInt(i.BYTES*8)-Q,a=A=>r.create(A),h=t.uvRatio||((A,y)=>{try{return{isValid:!0,value:r.sqrt(r.div(A,y))}}catch{return{isValid:!1,value:Et}}});if(!so(r,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function w(A,y,m=!1){const E=m?Q:Et;return Ze("coordinate "+A,y,E,c),y}function S(A){if(!(A instanceof d))throw new Error("EdwardsPoint expected")}const _=we((A,y)=>{const{X:m,Y:E,Z:R}=A,O=A.is0();y==null&&(y=O?io:r.inv(R));const T=a(m*y),k=a(E*y),p=r.mul(R,y);if(O)return{x:Et,y:Q};if(p!==Q)throw new Error("invZ was invalid");return{x:T,y:k}}),B=we(A=>{const{a:y,d:m}=s;if(A.is0())throw new Error("bad point: ZERO");const{X:E,Y:R,Z:O,T}=A,k=a(E*E),p=a(R*R),b=a(O*O),N=a(b*b),M=a(k*y),U=a(b*a(M+p)),l=a(N+a(m*a(k*p)));if(U!==l)throw new Error("bad point: equation left != right (1)");const f=a(E*R),u=a(O*T);if(f!==u)throw new Error("bad point: equation left != right (2)");return!0});class d{static BASE=new d(s.Gx,s.Gy,Q,a(s.Gx*s.Gy));static ZERO=new d(Et,Q,Q,Et);static Fp=r;static Fn=i;X;Y;Z;T;constructor(y,m,E,R){this.X=w("x",y),this.Y=w("y",m),this.Z=w("z",E,!0),this.T=w("t",R),Object.freeze(this)}static CURVE(){return s}static fromAffine(y){if(y instanceof d)throw new Error("extended point not allowed");const{x:m,y:E}=y||{};return w("x",m),w("y",E),new d(m,E,Q,a(m*E))}static fromBytes(y,m=!1){const E=r.BYTES,{a:R,d:O}=s;y=ze(q(y,E,"point")),Ut(m,"zip215");const T=ze(y),k=y[E-1];T[E-1]=k&-129;const p=Ht(T),b=m?c:r.ORDER;Ze("point.y",p,Et,b);const N=a(p*p),M=a(N-Q),U=a(O*N-R);let{isValid:l,value:f}=h(M,U);if(!l)throw new Error("bad point: invalid y coordinate");const u=(f&Q)===Q,g=(k&128)!==0;if(!m&&f===Et&&g)throw new Error("bad point: x=0 and x_0=1");return g!==u&&(f=a(-f)),d.fromAffine({x:f,y:p})}static fromHex(y,m=!1){return d.fromBytes(Yt(y),m)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(y=8,m=!0){return D.createCache(this,y),m||this.multiply(Ne),this}assertValidity(){B(this)}equals(y){S(y);const{X:m,Y:E,Z:R}=this,{X:O,Y:T,Z:k}=y,p=a(m*k),b=a(O*R),N=a(E*k),M=a(T*R);return p===b&&N===M}is0(){return this.equals(d.ZERO)}negate(){return new d(a(-this.X),this.Y,this.Z,a(-this.T))}double(){const{a:y}=s,{X:m,Y:E,Z:R}=this,O=a(m*m),T=a(E*E),k=a(Ne*a(R*R)),p=a(y*O),b=m+E,N=a(a(b*b)-O-T),M=p+T,U=M-k,l=p-T,f=a(N*U),u=a(M*l),g=a(N*l),x=a(U*M);return new d(f,u,x,g)}add(y){S(y);const{a:m,d:E}=s,{X:R,Y:O,Z:T,T:k}=this,{X:p,Y:b,Z:N,T:M}=y,U=a(R*p),l=a(O*b),f=a(k*E*M),u=a(T*N),g=a((R+O)*(p+b)-U-l),x=u-f,I=u+f,K=a(l-m*U),v=a(g*x),L=a(I*K),C=a(g*K),j=a(x*I);return new d(v,L,j,C)}subtract(y){return this.add(y.negate())}multiply(y){if(!i.isValidNot0(y))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:m,f:E}=D.cached(this,y,R=>jt(d,R));return jt(d,[m,E])[0]}multiplyUnsafe(y,m=d.ZERO){if(!i.isValid(y))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return y===Et?d.ZERO:this.is0()||y===Q?this:D.unsafe(this,y,E=>jt(d,E),m)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return D.unsafe(this,s.n).is0()}toAffine(y){return _(this,y)}clearCofactor(){return o===Q?this:this.multiplyUnsafe(o)}toBytes(){const{x:y,y:m}=this.toAffine(),E=r.toBytes(m);return E[E.length-1]|=y&Q?128:0,E}toHex(){return Jt(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const D=new xr(d,i.BITS);return d.BASE.precompute(8),d}function ao(e,t,n={}){if(typeof t!="function")throw new Error('"hash" function param is required');ne(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:i,Fp:s,Fn:o}=e,c=n.randomBytes||Xe,a=n.adjustScalarBytes||(p=>p),h=n.domain||((p,b,N)=>{if(Ut(N,"phflag"),b.length||N)throw new Error("Contexts/pre-hash are not supported");return p});function w(p){return o.create(Ht(p))}function S(p){const b=E.secretKey;q(p,E.secretKey,"secretKey");const N=q(t(p),2*b,"hashedSecretKey"),M=a(N.slice(0,b)),U=N.slice(b,2*b),l=w(M);return{head:M,prefix:U,scalar:l}}function _(p){const{head:b,prefix:N,scalar:M}=S(p),U=i.multiply(M),l=U.toBytes();return{head:b,prefix:N,scalar:M,point:U,pointBytes:l}}function B(p){return _(p).pointBytes}function d(p=Uint8Array.of(),...b){const N=yt(...b);return w(t(h(N,q(p,void 0,"context"),!!r)))}function D(p,b,N={}){p=q(p,void 0,"message"),r&&(p=r(p));const{prefix:M,scalar:U,pointBytes:l}=_(b),f=d(N.context,M,p),u=i.multiply(f).toBytes(),g=d(N.context,u,l,p),x=o.create(f+g*U);if(!o.isValid(x))throw new Error("sign failed: invalid s");const I=yt(u,o.toBytes(x));return q(I,E.signature,"result")}const A={zip215:!0};function y(p,b,N,M=A){const{context:U,zip215:l}=M,f=E.signature;p=q(p,f,"signature"),b=q(b,void 0,"message"),N=q(N,E.publicKey,"publicKey"),l!==void 0&&Ut(l,"zip215"),r&&(b=r(b));const u=f/2,g=p.subarray(0,u),x=Ht(p.subarray(u,f));let I,K,v;try{I=e.fromBytes(N,l),K=e.fromBytes(g,l),v=i.multiplyUnsafe(x)}catch{return!1}if(!l&&I.isSmallOrder())return!1;const L=d(U,K.toBytes(),I.toBytes(),b);return K.add(I.multiplyUnsafe(L)).subtract(v).clearCofactor().is0()}const m=s.BYTES,E={secretKey:m,publicKey:m,signature:2*m,seed:m};function R(p=c(E.seed)){return q(p,E.seed,"seed")}function O(p){return Ge(p)&&p.length===o.BYTES}function T(p,b){try{return!!e.fromBytes(p,b)}catch{return!1}}const k={getExtendedPublicKey:_,randomSecretKey:R,isValidSecretKey:O,isValidPublicKey:T,toMontgomery(p){const{y:b}=e.fromBytes(p),N=E.publicKey,M=N===32;if(!M&&N!==57)throw new Error("only defined for 25519 and 448");const U=M?s.div(Q+b,Q-b):s.div(b-Q,b+Q);return s.toBytes(U)},toMontgomerySecret(p){const b=E.secretKey;q(p,b);const N=t(p.subarray(0,b));return a(N).subarray(0,b)}};return Object.freeze({keygen:Br(R,B),getPublicKey:B,sign:D,verify:y,utils:k,Point:e,lengths:E})}const co=BigInt(1),Cn=BigInt(2),uo=BigInt(5),fo=BigInt(8),sn=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),lo={p:sn,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:fo,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function ho(e){const t=BigInt(10),n=BigInt(20),r=BigInt(40),i=BigInt(80),s=sn,c=e*e%s*e%s,a=H(c,Cn,s)*c%s,h=H(a,co,s)*e%s,w=H(h,uo,s)*h%s,S=H(w,t,s)*w%s,_=H(S,n,s)*S%s,B=H(_,r,s)*_%s,d=H(B,i,s)*B%s,D=H(d,i,s)*B%s,A=H(D,t,s)*w%s;return{pow_p_5_8:H(A,Cn,s)*e%s,b2:c}}function yo(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const Nn=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function wo(e,t){const n=sn,r=G(t*t*t,n),i=G(r*r*t,n),s=ho(e*i).pow_p_5_8;let o=G(e*r*s,n);const c=G(t*o*o,n),a=o,h=G(o*Nn,n),w=c===e,S=c===G(-e,n),_=c===G(-e*Nn,n);return w&&(o=a),(S||_)&&(o=h),Gs(o,n)&&(o=G(-o,n)),{isValid:w||S,value:o}}const bo=oo(lo,{uvRatio:wo});function go(e){return ao(bo,Wr,Object.assign({adjustScalarBytes:yo},e))}const Xt=go({});class On extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}}class Tn extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class po extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const J={get(e=globalThis){const t=e.crypto;if(t?.subtle==null)throw new po("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return t}},Gt=32,dt=64,ge=32;let Nt;const Ir=(async()=>{try{return await J.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function mo(){const e=Xt.utils.randomSecretKey(),t=Xt.getPublicKey(e);return{privateKey:_r(e,t),publicKey:t}}function Eo(e){if(e.length!==ge)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=Xt.getPublicKey(t);return{privateKey:_r(t,n),publicKey:n}}async function So(e,t){let n;e.length===dt?n=e.subarray(0,32):n=e;const r={crv:"Ed25519",kty:"OKP",x:$(e.subarray(32),"base64url"),d:$(n,"base64url"),ext:!0,key_ops:["sign"]},i=await J.get().subtle.importKey("jwk",r,{name:"Ed25519"},!0,["sign"]),s=await J.get().subtle.sign({name:"Ed25519"},i,t instanceof Uint8Array?t:t.subarray());return new Uint8Array(s,0,s.byteLength)}function Ao(e,t){const n=e.subarray(0,ge);return Xt.sign(t instanceof Uint8Array?t:t.subarray(),n)}async function xo(e,t){return Nt==null&&(Nt=await Ir),Nt?So(e,t):Ao(e,t)}async function vo(e,t,n){if(e.buffer instanceof ArrayBuffer){const r=await J.get().subtle.importKey("raw",e.buffer,{name:"Ed25519"},!1,["verify"]);return await J.get().subtle.verify({name:"Ed25519"},r,t,n instanceof Uint8Array?n:n.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}function Bo(e,t,n){return Xt.verify(t,n instanceof Uint8Array?n:n.subarray(),e)}async function Io(e,t,n){return Nt==null&&(Nt=await Ir),Nt?vo(e,t,n):Bo(e,t,n)}function _r(e,t){const n=new Uint8Array(dt);for(let r=0;r<ge;r++)n[r]=e[r],n[ge+r]=t[r];return n}function kn(e,t){let n=W(e,"base64urlpad");if(t!=null){if(n.length>t)throw new Error("byte array longer than desired length");n=Tt([new Uint8Array(t-n.length),n])}return n}function _e(e){return e==null?!1:typeof e.then=="function"&&typeof e.catch=="function"&&typeof e.finally=="function"}class Kr{type="Ed25519";raw;constructor(t){this.raw=Wt(t,Gt)}toMultihash(){return Je.digest(Re(this))}toCID(){return X.createV1(114,this.toMultihash())}toString(){return ft.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}verify(t,n,r){r?.signal?.throwIfAborted();const i=Io(this.raw,n,t);return _e(i)?i.then(s=>(r?.signal?.throwIfAborted(),s)):i}}class pe{type="Ed25519";raw;publicKey;constructor(t,n){this.raw=Wt(t,dt),this.publicKey=new Kr(n)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}sign(t,n){n?.signal?.throwIfAborted();const r=xo(this.raw,t);return _e(r)?r.then(i=>(n?.signal?.throwIfAborted(),i)):(n?.signal?.throwIfAborted(),r)}}function Rr(e){if(e.length>dt){e=Wt(e,dt+Gt);const r=e.subarray(0,dt),i=e.subarray(dt,e.length);return new pe(r,i)}e=Wt(e,dt);const t=e.subarray(0,dt),n=e.subarray(Gt);return new pe(t,n)}function on(e){return e=Wt(e,Gt),new Kr(e)}async function _o(){const{privateKey:e,publicKey:t}=mo();return new pe(e,t)}async function Ko(e){const{privateKey:t,publicKey:n}=Eo(e);return new pe(t,n)}function Wt(e,t){if(e=Uint8Array.from(e??[]),e.length!==t)throw new V(`Key must be a Uint8Array of length ${t}, got ${e.length}`);return e}const Ro=Math.pow(2,7),Uo=Math.pow(2,14),Do=Math.pow(2,21),Ur=Math.pow(2,28),Dr=Math.pow(2,35),Lr=Math.pow(2,42),Cr=Math.pow(2,49),ot=128,St=127;function an(e){if(e<Ro)return 1;if(e<Uo)return 2;if(e<Do)return 3;if(e<Ur)return 4;if(e<Dr)return 5;if(e<Lr)return 6;if(e<Cr)return 7;if(Number.MAX_SAFE_INTEGER!=null&&e>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return 8}function Lo(e,t,n=0){switch(an(e)){case 8:t[n++]=e&255|ot,e/=128;case 7:t[n++]=e&255|ot,e/=128;case 6:t[n++]=e&255|ot,e/=128;case 5:t[n++]=e&255|ot,e/=128;case 4:t[n++]=e&255|ot,e>>>=7;case 3:t[n++]=e&255|ot,e>>>=7;case 2:t[n++]=e&255|ot,e>>>=7;case 1:{t[n++]=e&255,e>>>=7;break}default:throw new Error("unreachable")}return t}function Co(e,t){let n=e[t],r=0;if(r+=n&St,n<ot||(n=e[t+1],r+=(n&St)<<7,n<ot)||(n=e[t+2],r+=(n&St)<<14,n<ot)||(n=e[t+3],r+=(n&St)<<21,n<ot)||(n=e[t+4],r+=(n&St)*Ur,n<ot)||(n=e[t+5],r+=(n&St)*Dr,n<ot)||(n=e[t+6],r+=(n&St)*Lr,n<ot)||(n=e[t+7],r+=(n&St)*Cr,n<ot))return r;throw new RangeError("Could not decode varint")}const cn=new Float32Array([-0]),xt=new Uint8Array(cn.buffer);function No(e,t,n){cn[0]=e,t[n]=xt[0],t[n+1]=xt[1],t[n+2]=xt[2],t[n+3]=xt[3]}function Oo(e,t){return xt[0]=e[t],xt[1]=e[t+1],xt[2]=e[t+2],xt[3]=e[t+3],cn[0]}const un=new Float64Array([-0]),it=new Uint8Array(un.buffer);function To(e,t,n){un[0]=e,t[n]=it[0],t[n+1]=it[1],t[n+2]=it[2],t[n+3]=it[3],t[n+4]=it[4],t[n+5]=it[5],t[n+6]=it[6],t[n+7]=it[7]}function ko(e,t){return it[0]=e[t],it[1]=e[t+1],it[2]=e[t+2],it[3]=e[t+3],it[4]=e[t+4],it[5]=e[t+5],it[6]=e[t+6],it[7]=e[t+7],un[0]}const Mo=BigInt(Number.MAX_SAFE_INTEGER),Po=BigInt(Number.MIN_SAFE_INTEGER);class st{lo;hi;constructor(t,n){this.lo=t|0,this.hi=n|0}toNumber(t=!1){if(!t&&this.hi>>>31>0){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(n+r*4294967296)}return this.lo+this.hi*4294967296}toBigInt(t=!1){if(t)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const n=~this.lo+1>>>0;let r=~this.hi>>>0;return n===0&&(r=r+1>>>0),-(BigInt(n)+(BigInt(r)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toString(t=!1){return this.toBigInt(t).toString()}zzEncode(){const t=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^t)>>>0,this.lo=(this.lo<<1^t)>>>0,this}zzDecode(){const t=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^t)>>>0,this.hi=(this.hi>>>1^t)>>>0,this}length(){const t=this.lo,n=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?n===0?t<16384?t<128?1:2:t<2097152?3:4:n<16384?n<128?5:6:n<2097152?7:8:r<128?9:10}static fromBigInt(t){if(t===0n)return Kt;if(t<Mo&&t>Po)return this.fromNumber(Number(t));const n=t<0n;n&&(t=-t);let r=t>>32n,i=t-(r<<32n);return n&&(r=~r|0n,i=~i|0n,++i>Mn&&(i=0n,++r>Mn&&(r=0n))),new st(Number(i),Number(r))}static fromNumber(t){if(t===0)return Kt;const n=t<0;n&&(t=-t);let r=t>>>0,i=(t-r)/4294967296>>>0;return n&&(i=~i>>>0,r=~r>>>0,++r>4294967295&&(r=0,++i>4294967295&&(i=0))),new st(r,i)}static from(t){return typeof t=="number"?st.fromNumber(t):typeof t=="bigint"?st.fromBigInt(t):typeof t=="string"?st.fromBigInt(BigInt(t)):t.low!=null||t.high!=null?new st(t.low>>>0,t.high>>>0):Kt}}const Kt=new st(0,0);Kt.toBigInt=function(){return 0n};Kt.zzEncode=Kt.zzDecode=function(){return this};Kt.length=function(){return 1};const Mn=4294967296n;function $o(e){let t=0,n=0;for(let r=0;r<e.length;++r)n=e.charCodeAt(r),n<128?t+=1:n<2048?t+=2:(n&64512)===55296&&(e.charCodeAt(r+1)&64512)===56320?(++r,t+=4):t+=3;return t}function qo(e,t,n){if(n-t<1)return"";let i;const s=[];let o=0,c;for(;t<n;)c=e[t++],c<128?s[o++]=c:c>191&&c<224?s[o++]=(c&31)<<6|e[t++]&63:c>239&&c<365?(c=((c&7)<<18|(e[t++]&63)<<12|(e[t++]&63)<<6|e[t++]&63)-65536,s[o++]=55296+(c>>10),s[o++]=56320+(c&1023)):s[o++]=(c&15)<<12|(e[t++]&63)<<6|e[t++]&63,o>8191&&((i??(i=[])).push(String.fromCharCode.apply(String,s)),o=0);return i!=null?(o>0&&i.push(String.fromCharCode.apply(String,s.slice(0,o))),i.join("")):String.fromCharCode.apply(String,s.slice(0,o))}function Nr(e,t,n){const r=n;let i,s;for(let o=0;o<e.length;++o)i=e.charCodeAt(o),i<128?t[n++]=i:i<2048?(t[n++]=i>>6|192,t[n++]=i&63|128):(i&64512)===55296&&((s=e.charCodeAt(o+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++o,t[n++]=i>>18|240,t[n++]=i>>12&63|128,t[n++]=i>>6&63|128,t[n++]=i&63|128):(t[n++]=i>>12|224,t[n++]=i>>6&63|128,t[n++]=i&63|128);return n-r}function lt(e,t){return RangeError(`index out of range: ${e.pos} + ${t??1} > ${e.len}`)}function oe(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}class Vo{buf;pos;len;_slice=Uint8Array.prototype.subarray;constructor(t){this.buf=t,this.pos=0,this.len=t.length}uint32(){let t=4294967295;if(t=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(t=(t|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(t=(t|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return t;if((this.pos+=5)>this.len)throw this.pos=this.len,lt(this,10);return t}int32(){return this.uint32()|0}sint32(){const t=this.uint32();return t>>>1^-(t&1)|0}bool(){return this.uint32()!==0}fixed32(){if(this.pos+4>this.len)throw lt(this,4);return oe(this.buf,this.pos+=4)}sfixed32(){if(this.pos+4>this.len)throw lt(this,4);return oe(this.buf,this.pos+=4)|0}float(){if(this.pos+4>this.len)throw lt(this,4);const t=Oo(this.buf,this.pos);return this.pos+=4,t}double(){if(this.pos+8>this.len)throw lt(this,4);const t=ko(this.buf,this.pos);return this.pos+=8,t}bytes(){const t=this.uint32(),n=this.pos,r=this.pos+t;if(r>this.len)throw lt(this,t);return this.pos+=t,n===r?new Uint8Array(0):this.buf.subarray(n,r)}string(){const t=this.bytes();return qo(t,0,t.length)}skip(t){if(typeof t=="number"){if(this.pos+t>this.len)throw lt(this,t);this.pos+=t}else do if(this.pos>=this.len)throw lt(this);while((this.buf[this.pos++]&128)!==0);return this}skipType(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error(`invalid wire type ${t} at offset ${this.pos}`)}return this}readLongVarint(){const t=new st(0,0);let n=0;if(this.len-this.pos>4){for(;n<4;++n)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;n=0}else{for(;n<3;++n){if(this.pos>=this.len)throw lt(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<n*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<n*7)>>>0,t}if(this.len-this.pos>4){for(;n<5;++n)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;n<5;++n){if(this.pos>=this.len)throw lt(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<n*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}readFixed64(){if(this.pos+8>this.len)throw lt(this,8);const t=oe(this.buf,this.pos+=4),n=oe(this.buf,this.pos+=4);return new st(t,n)}int64(){return this.readLongVarint().toBigInt()}int64Number(){return this.readLongVarint().toNumber()}int64String(){return this.readLongVarint().toString()}uint64(){return this.readLongVarint().toBigInt(!0)}uint64Number(){const t=Co(this.buf,this.pos);return this.pos+=an(t),t}uint64String(){return this.readLongVarint().toString(!0)}sint64(){return this.readLongVarint().zzDecode().toBigInt()}sint64Number(){return this.readLongVarint().zzDecode().toNumber()}sint64String(){return this.readLongVarint().zzDecode().toString()}fixed64(){return this.readFixed64().toBigInt()}fixed64Number(){return this.readFixed64().toNumber()}fixed64String(){return this.readFixed64().toString()}sfixed64(){return this.readFixed64().toBigInt()}sfixed64Number(){return this.readFixed64().toNumber()}sfixed64String(){return this.readFixed64().toString()}}function zo(e){return new Vo(e instanceof Uint8Array?e:e.subarray())}function Or(e,t,n){const r=zo(e);return t.decode(r,void 0,n)}function Zo(e){let r,i=8192;return function(o){if(o<1||o>4096)return Rt(o);i+o>8192&&(r=Rt(8192),i=0);const c=r.subarray(i,i+=o);return(i&7)!==0&&(i=(i|7)+1),c}}class Vt{fn;len;next;val;constructor(t,n,r){this.fn=t,this.len=n,this.next=void 0,this.val=r}}function Oe(){}class jo{head;tail;len;next;constructor(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}}const Fo=Zo();function Yo(e){return globalThis.Buffer!=null?Rt(e):Fo(e)}class je{len;head;tail;states;constructor(){this.len=0,this.head=new Vt(Oe,0,0),this.tail=this.head,this.states=null}_push(t,n,r){return this.tail=this.tail.next=new Vt(t,n,r),this.len+=n,this}uint32(t){return this.len+=(this.tail=this.tail.next=new Xo((t=t>>>0)<128?1:t<16384?2:t<2097152?3:t<268435456?4:5,t)).len,this}int32(t){return t<0?this._push(ae,10,st.fromNumber(t)):this.uint32(t)}sint32(t){return this.uint32((t<<1^t>>31)>>>0)}uint64(t){const n=st.fromBigInt(t);return this._push(ae,n.length(),n)}uint64Number(t){return this._push(Lo,an(t),t)}uint64String(t){return this.uint64(BigInt(t))}int64(t){return this.uint64(t)}int64Number(t){return this.uint64Number(t)}int64String(t){return this.uint64String(t)}sint64(t){const n=st.fromBigInt(t).zzEncode();return this._push(ae,n.length(),n)}sint64Number(t){const n=st.fromNumber(t).zzEncode();return this._push(ae,n.length(),n)}sint64String(t){return this.sint64(BigInt(t))}bool(t){return this._push(Te,1,t?1:0)}fixed32(t){return this._push(qt,4,t>>>0)}sfixed32(t){return this.fixed32(t)}fixed64(t){const n=st.fromBigInt(t);return this._push(qt,4,n.lo)._push(qt,4,n.hi)}fixed64Number(t){const n=st.fromNumber(t);return this._push(qt,4,n.lo)._push(qt,4,n.hi)}fixed64String(t){return this.fixed64(BigInt(t))}sfixed64(t){return this.fixed64(t)}sfixed64Number(t){return this.fixed64Number(t)}sfixed64String(t){return this.fixed64String(t)}float(t){return this._push(No,4,t)}double(t){return this._push(To,8,t)}bytes(t){const n=t.length>>>0;return n===0?this._push(Te,1,0):this.uint32(n)._push(Go,n,t)}string(t){const n=$o(t);return n!==0?this.uint32(n)._push(Nr,n,t):this._push(Te,1,0)}fork(){return this.states=new jo(this),this.head=this.tail=new Vt(Oe,0,0),this.len=0,this}reset(){return this.states!=null?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Vt(Oe,0,0),this.len=0),this}ldelim(){const t=this.head,n=this.tail,r=this.len;return this.reset().uint32(r),r!==0&&(this.tail.next=t.next,this.tail=n,this.len+=r),this}finish(){let t=this.head.next;const n=Yo(this.len);let r=0;for(;t!=null;)t.fn(t.val,n,r),r+=t.len,t=t.next;return n}}function Te(e,t,n){t[n]=e&255}function Ho(e,t,n){for(;e>127;)t[n++]=e&127|128,e>>>=7;t[n]=e}class Xo extends Vt{next;constructor(t,n){super(Ho,t,n),this.next=void 0}}function ae(e,t,n){for(;e.hi!==0;)t[n++]=e.lo&127|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=e.lo&127|128,e.lo=e.lo>>>7;t[n++]=e.lo}function qt(e,t,n){t[n]=e&255,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function Go(e,t,n){t.set(e,n)}globalThis.Buffer!=null&&(je.prototype.bytes=function(e){const t=e.length>>>0;return this.uint32(t),t>0&&this._push(Wo,t,e),this},je.prototype.string=function(e){const t=globalThis.Buffer.byteLength(e);return this.uint32(t),t>0&&this._push(Jo,t,e),this});function Wo(e,t,n){t.set(e,n)}function Jo(e,t,n){e.length<40?Nr(e,t,n):t.utf8Write!=null?t.utf8Write(e,n):t.set(W(e),n)}function Qo(){return new je}function Tr(e,t){const n=Qo();return t.encode(e,n,{lengthDelimited:!1}),n.finish()}var me;(function(e){e[e.VARINT=0]="VARINT",e[e.BIT64=1]="BIT64",e[e.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",e[e.START_GROUP=3]="START_GROUP",e[e.END_GROUP=4]="END_GROUP",e[e.BIT32=5]="BIT32"})(me||(me={}));function kr(e,t,n,r){return{name:e,type:t,encode:n,decode:r}}function ta(e){function t(i){if(e[i.toString()]==null)throw new Error("Invalid enum value");return e[i]}const n=function(s,o){const c=t(s);o.int32(c)},r=function(s){const o=s.int32();return t(o)};return kr("enum",me.VARINT,n,r)}function Mr(e,t){return kr("message",me.LENGTH_DELIMITED,e,t)}var Z;(function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.secp256k1="secp256k1",e.ECDSA="ECDSA"})(Z||(Z={}));var Fe;(function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.secp256k1=2]="secp256k1",e[e.ECDSA=3]="ECDSA"})(Fe||(Fe={}));(function(e){e.codec=()=>ta(Fe)})(Z||(Z={}));var vt;(function(e){let t;e.codec=()=>(t==null&&(t=Mr((n,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),Z.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),i.lengthDelimited!==!1&&r.ldelim()},(n,r,i={})=>{const s={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const c=n.uint32();switch(c>>>3){case 1:{s.Type=Z.codec().decode(n);break}case 2:{s.Data=n.bytes();break}default:{n.skipType(c&7);break}}}return s})),t),e.encode=n=>Tr(n,e.codec()),e.decode=(n,r)=>Or(n,e.codec(),r)})(vt||(vt={}));var Ee;(function(e){let t;e.codec=()=>(t==null&&(t=Mr((n,r,i={})=>{i.lengthDelimited!==!1&&r.fork(),n.Type!=null&&(r.uint32(8),Z.codec().encode(n.Type,r)),n.Data!=null&&(r.uint32(18),r.bytes(n.Data)),i.lengthDelimited!==!1&&r.ldelim()},(n,r,i={})=>{const s={},o=r==null?n.len:n.pos+r;for(;n.pos<o;){const c=n.uint32();switch(c>>>3){case 1:{s.Type=Z.codec().decode(n);break}case 2:{s.Data=n.bytes();break}default:{n.skipType(c&7);break}}}return s})),t),e.encode=n=>Tr(n,e.codec()),e.decode=(n,r)=>Or(n,e.codec(),r)})(Ee||(Ee={}));class fn{type="RSA";jwk;_raw;_multihash;constructor(t,n){this.jwk=t,this._multihash=n}get raw(){return this._raw==null&&(this._raw=hn(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return X.createV1(114,this._multihash)}toString(){return ft.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}verify(t,n,r){return da(this.jwk,n,t,r)}}class Pr{type="RSA";jwk;_raw;publicKey;constructor(t,n){this.jwk=t,this.publicKey=n}get raw(){return this._raw==null&&(this._raw=ia(this.jwk)),this._raw}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}sign(t,n){return ha(this.jwk,t,n)}}const $r=8192,ln=18,ea=1062,na=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function ra(e){return{n:$(e[1],"base64url"),e:$(e[2],"base64url"),d:$(e[3],"base64url"),p:$(e[4],"base64url"),q:$(e[5],"base64url"),dp:$(e[6],"base64url"),dq:$(e[7],"base64url"),qi:$(e[8],"base64url"),kty:"RSA"}}function ia(e){if(e.n==null||e.e==null||e.d==null||e.p==null||e.q==null||e.dp==null||e.dq==null||e.qi==null)throw new V("JWK was missing components");return gt([ut(Uint8Array.from([0])),ut(W(e.n,"base64url")),ut(W(e.e,"base64url")),ut(W(e.d,"base64url")),ut(W(e.p,"base64url")),ut(W(e.q,"base64url")),ut(W(e.dp,"base64url")),ut(W(e.dq,"base64url")),ut(W(e.qi,"base64url"))]).subarray()}function sa(e){const t=Bt(e[1],{offset:0});return{kty:"RSA",n:$(t[0],"base64url"),e:$(t[1],"base64url")}}function hn(e){if(e.n==null||e.e==null)throw new V("JWK was missing components");return gt([na,Qe(gt([ut(W(e.n,"base64url")),ut(W(e.e,"base64url"))]))]).subarray()}function oa(e){const t=Bt(e);return qr(t)}function qr(e){const t=ra(e);return zr(t)}function aa(e,t){if(e.byteLength>=ea)throw new qn("Key size is too large");const n=Bt(e,{offset:0});return Vr(n,e,t)}function Vr(e,t,n){const r=sa(e);if(n==null){const i=Se(vt.encode({Type:Z.RSA,Data:t}));n=Mt(ln,i)}return new fn(r,n)}function zr(e){if(wa(e)>$r)throw new V("Key size is too large");const t=ua(e),n=Se(vt.encode({Type:Z.RSA,Data:hn(t.publicKey)})),r=Mt(ln,n);return new Pr(t.privateKey,new fn(t.publicKey,r))}async function ca(e){if(e>$r)throw new V("Key size is too large");const t=await la(e),n=Se(vt.encode({Type:Z.RSA,Data:hn(t.publicKey)})),r=Mt(ln,n);return new Pr(t.privateKey,new fn(t.publicKey,r))}function ua(e){if(e==null)throw new V("Missing key parameter");return{privateKey:e,publicKey:{kty:e.kty,n:e.n,e:e.e}}}const fa="1.2.840.113549.1.1.1";async function la(e,t){const n=await J.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),r=await ya(n);return{privateKey:r[0],publicKey:r[1]}}async function ha(e,t,n){const r=await J.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);n?.signal?.throwIfAborted();const i=await J.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},r,t instanceof Uint8Array?t:t.subarray());return n?.signal?.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}async function da(e,t,n,r){const i=await J.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);r?.signal?.throwIfAborted();const s=await J.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,t,n instanceof Uint8Array?n:n.subarray());return r?.signal?.throwIfAborted(),s}async function ya(e,t){if(e.privateKey==null||e.publicKey==null)throw new V("Private and public key are required");return await Promise.all([J.get().subtle.exportKey("jwk",e.privateKey),J.get().subtle.exportKey("jwk",e.publicKey)])}function wa(e){if(e.kty!=="RSA")throw new V("invalid key type");if(e.n==null)throw new V("invalid key modulus");return W(e.n,"base64url").length*8}const Pn=(e,t)=>(e+(e>=0?t:-t)/Zr)/t;function ba(e,t,n){const[[r,i],[s,o]]=t,c=Pn(o*e,n),a=Pn(-i*e,n);let h=e-c*r-a*s,w=-c*i-a*o;const S=h<bt,_=w<bt;S&&(h=-h),_&&(w=-w);const B=nn(Math.ceil(zs(n)/2))+Ot;if(h<bt||h>=B||w<bt||w>=B)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:S,k1:h,k2neg:_,k2:w}}function Ye(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function ke(e,t){const n={};for(let r of Object.keys(t))n[r]=e[r]===void 0?t[r]:e[r];return Ut(n.lowS,"lowS"),Ut(n.prehash,"prehash"),n.format!==void 0&&Ye(n.format),n}class ga extends Error{constructor(t=""){super(t)}}const At={Err:ga,_tlv:{encode:(e,t)=>{const{Err:n}=At;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length&1)throw new n("tlv.encode: unpadded data");const r=t.length/2,i=se(r);if(i.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?se(i.length/2|128):"";return se(e)+s+i+t},decode(e,t){const{Err:n}=At;let r=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(t.length<2||t[r++]!==e)throw new n("tlv.decode: wrong tlv");const i=t[r++],s=!!(i&128);let o=0;if(!s)o=i;else{const a=i&127;if(!a)throw new n("tlv.decode(long): indefinite length not supported");if(a>4)throw new n("tlv.decode(long): byte length is too big");const h=t.subarray(r,r+a);if(h.length!==a)throw new n("tlv.decode: length bytes not complete");if(h[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const w of h)o=o<<8|w;if(r+=a,o<128)throw new n("tlv.decode(long): not minimal encoding")}const c=t.subarray(r,r+o);if(c.length!==o)throw new n("tlv.decode: wrong value length");return{v:c,l:t.subarray(r+o)}}},_int:{encode(e){const{Err:t}=At;if(e<bt)throw new t("integer: negative integers are not allowed");let n=se(e);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:t}=At;if(e[0]&128)throw new t("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return Be(e)}},toSig(e){const{Err:t,_int:n,_tlv:r}=At,i=q(e,void 0,"signature"),{v:s,l:o}=r.decode(48,i);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:c,l:a}=r.decode(2,s),{v:h,l:w}=r.decode(2,a);if(w.length)throw new t("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(h)}},hexFromSig(e){const{_tlv:t,_int:n}=At,r=t.encode(2,n.encode(e.r)),i=t.encode(2,n.encode(e.s)),s=r+i;return t.encode(48,s)}},bt=BigInt(0),Ot=BigInt(1),Zr=BigInt(2),ce=BigInt(3),pa=BigInt(4);function ma(e,t={}){const n=vr("weierstrass",e,t),{Fp:r,Fn:i}=n;let s=n.CURVE;const{h:o,n:c}=s;ne(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});const{endo:a}=t;if(a&&(!r.is0(s.a)||typeof a.beta!="bigint"||!Array.isArray(a.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const h=Fr(r,i);function w(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function S(U,l,f){const{x:u,y:g}=l.toAffine(),x=r.toBytes(u);if(Ut(f,"isCompressed"),f){w();const I=!r.isOdd(g);return yt(jr(I),x)}else return yt(Uint8Array.of(4),x,r.toBytes(g))}function _(U){q(U,void 0,"Point");const{publicKey:l,publicKeyUncompressed:f}=h,u=U.length,g=U[0],x=U.subarray(1);if(u===l&&(g===2||g===3)){const I=r.fromBytes(x);if(!r.isValid(I))throw new Error("bad point: is not on curve, wrong x");const K=D(I);let v;try{v=r.sqrt(K)}catch(j){const z=j instanceof Error?": "+j.message:"";throw new Error("bad point: is not on curve, sqrt error"+z)}w();const L=r.isOdd(v);return(g&1)===1!==L&&(v=r.neg(v)),{x:I,y:v}}else if(u===f&&g===4){const I=r.BYTES,K=r.fromBytes(x.subarray(0,I)),v=r.fromBytes(x.subarray(I,I*2));if(!A(K,v))throw new Error("bad point: is not on curve");return{x:K,y:v}}else throw new Error(`bad point: got length ${u}, expected compressed=${l} or uncompressed=${f}`)}const B=t.toBytes||S,d=t.fromBytes||_;function D(U){const l=r.sqr(U),f=r.mul(l,U);return r.add(r.add(f,r.mul(U,s.a)),s.b)}function A(U,l){const f=r.sqr(l),u=D(U);return r.eql(f,u)}if(!A(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const y=r.mul(r.pow(s.a,ce),pa),m=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(y,m)))throw new Error("bad curve params: a or b");function E(U,l,f=!1){if(!r.isValid(l)||f&&r.is0(l))throw new Error(`bad point coordinate ${U}`);return l}function R(U){if(!(U instanceof b))throw new Error("Weierstrass Point expected")}function O(U){if(!a||!a.basises)throw new Error("no endo");return ba(U,a.basises,i.ORDER)}const T=we((U,l)=>{const{X:f,Y:u,Z:g}=U;if(r.eql(g,r.ONE))return{x:f,y:u};const x=U.is0();l==null&&(l=x?r.ONE:r.inv(g));const I=r.mul(f,l),K=r.mul(u,l),v=r.mul(g,l);if(x)return{x:r.ZERO,y:r.ZERO};if(!r.eql(v,r.ONE))throw new Error("invZ was invalid");return{x:I,y:K}}),k=we(U=>{if(U.is0()){if(t.allowInfinityPoint&&!r.is0(U.Y))return;throw new Error("bad point: ZERO")}const{x:l,y:f}=U.toAffine();if(!r.isValid(l)||!r.isValid(f))throw new Error("bad point: x or y not field elements");if(!A(l,f))throw new Error("bad point: equation left != right");if(!U.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function p(U,l,f,u,g){return f=new b(r.mul(f.X,U),f.Y,f.Z),l=be(u,l),f=be(g,f),l.add(f)}class b{static BASE=new b(s.Gx,s.Gy,r.ONE);static ZERO=new b(r.ZERO,r.ONE,r.ZERO);static Fp=r;static Fn=i;X;Y;Z;constructor(l,f,u){this.X=E("x",l),this.Y=E("y",f,!0),this.Z=E("z",u),Object.freeze(this)}static CURVE(){return s}static fromAffine(l){const{x:f,y:u}=l||{};if(!l||!r.isValid(f)||!r.isValid(u))throw new Error("invalid affine point");if(l instanceof b)throw new Error("projective point not allowed");return r.is0(f)&&r.is0(u)?b.ZERO:new b(f,u,r.ONE)}static fromBytes(l){const f=b.fromAffine(d(q(l,void 0,"point")));return f.assertValidity(),f}static fromHex(l){return b.fromBytes(Yt(l))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(l=8,f=!0){return M.createCache(this,l),f||this.multiply(ce),this}assertValidity(){k(this)}hasEvenY(){const{y:l}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(l)}equals(l){R(l);const{X:f,Y:u,Z:g}=this,{X:x,Y:I,Z:K}=l,v=r.eql(r.mul(f,K),r.mul(x,g)),L=r.eql(r.mul(u,K),r.mul(I,g));return v&&L}negate(){return new b(this.X,r.neg(this.Y),this.Z)}double(){const{a:l,b:f}=s,u=r.mul(f,ce),{X:g,Y:x,Z:I}=this;let K=r.ZERO,v=r.ZERO,L=r.ZERO,C=r.mul(g,g),j=r.mul(x,x),z=r.mul(I,I),P=r.mul(g,x);return P=r.add(P,P),L=r.mul(g,I),L=r.add(L,L),K=r.mul(l,L),v=r.mul(u,z),v=r.add(K,v),K=r.sub(j,v),v=r.add(j,v),v=r.mul(K,v),K=r.mul(P,K),L=r.mul(u,L),z=r.mul(l,z),P=r.sub(C,z),P=r.mul(l,P),P=r.add(P,L),L=r.add(C,C),C=r.add(L,C),C=r.add(C,z),C=r.mul(C,P),v=r.add(v,C),z=r.mul(x,I),z=r.add(z,z),C=r.mul(z,P),K=r.sub(K,C),L=r.mul(z,j),L=r.add(L,L),L=r.add(L,L),new b(K,v,L)}add(l){R(l);const{X:f,Y:u,Z:g}=this,{X:x,Y:I,Z:K}=l;let v=r.ZERO,L=r.ZERO,C=r.ZERO;const j=s.a,z=r.mul(s.b,ce);let P=r.mul(f,x),F=r.mul(u,I),tt=r.mul(g,K),ht=r.add(f,u),Y=r.add(x,I);ht=r.mul(ht,Y),Y=r.add(P,F),ht=r.sub(ht,Y),Y=r.add(f,g);let rt=r.add(x,K);return Y=r.mul(Y,rt),rt=r.add(P,tt),Y=r.sub(Y,rt),rt=r.add(u,g),v=r.add(I,K),rt=r.mul(rt,v),v=r.add(F,tt),rt=r.sub(rt,v),C=r.mul(j,Y),v=r.mul(z,tt),C=r.add(v,C),v=r.sub(F,C),C=r.add(F,C),L=r.mul(v,C),F=r.add(P,P),F=r.add(F,P),tt=r.mul(j,tt),Y=r.mul(z,Y),F=r.add(F,tt),tt=r.sub(P,tt),tt=r.mul(j,tt),Y=r.add(Y,tt),P=r.mul(F,Y),L=r.add(L,P),P=r.mul(rt,Y),v=r.mul(ht,v),v=r.sub(v,P),P=r.mul(ht,F),C=r.mul(rt,C),C=r.add(C,P),new b(v,L,C)}subtract(l){return this.add(l.negate())}is0(){return this.equals(b.ZERO)}multiply(l){const{endo:f}=t;if(!i.isValidNot0(l))throw new Error("invalid scalar: out of range");let u,g;const x=I=>M.cached(this,I,K=>jt(b,K));if(f){const{k1neg:I,k1:K,k2neg:v,k2:L}=O(l),{p:C,f:j}=x(K),{p:z,f:P}=x(L);g=j.add(P),u=p(f.beta,C,z,I,v)}else{const{p:I,f:K}=x(l);u=I,g=K}return jt(b,[u,g])[0]}multiplyUnsafe(l){const{endo:f}=t,u=this;if(!i.isValid(l))throw new Error("invalid scalar: out of range");if(l===bt||u.is0())return b.ZERO;if(l===Ot)return u;if(M.hasCache(this))return this.multiply(l);if(f){const{k1neg:g,k1:x,k2neg:I,k2:K}=O(l),{p1:v,p2:L}=ro(b,u,x,K);return p(f.beta,v,L,g,I)}else return M.unsafe(u,l)}toAffine(l){return T(this,l)}isTorsionFree(){const{isTorsionFree:l}=t;return o===Ot?!0:l?l(b,this):M.unsafe(this,c).is0()}clearCofactor(){const{clearCofactor:l}=t;return o===Ot?this:l?l(b,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(l=!0){return Ut(l,"isCompressed"),this.assertValidity(),B(b,this,l)}toHex(l=!0){return Jt(this.toBytes(l))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}const N=i.BITS,M=new xr(b,t.endo?Math.ceil(N/2):N);return b.BASE.precompute(8),b}function jr(e){return Uint8Array.of(e?2:3)}function Fr(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function Ea(e,t={}){const{Fn:n}=e,r=t.randomBytes||Xe,i=Object.assign(Fr(e.Fp,n),{seed:Er(n.ORDER)});function s(B){try{const d=n.fromBytes(B);return n.isValidNot0(d)}catch{return!1}}function o(B,d){const{publicKey:D,publicKeyUncompressed:A}=i;try{const y=B.length;return d===!0&&y!==D||d===!1&&y!==A?!1:!!e.fromBytes(B)}catch{return!1}}function c(B=r(i.seed)){return no(q(B,i.seed,"seed"),n.ORDER)}function a(B,d=!0){return e.BASE.multiply(n.fromBytes(B)).toBytes(d)}function h(B){const{secretKey:d,publicKey:D,publicKeyUncompressed:A}=i;if(!Ge(B)||"_lengths"in n&&n._lengths||d===D)return;const y=q(B,void 0,"key").length;return y===D||y===A}function w(B,d,D=!0){if(h(B)===!0)throw new Error("first arg must be private key");if(h(d)===!1)throw new Error("second arg must be public key");const A=n.fromBytes(B);return e.fromBytes(d).multiply(A).toBytes(D)}const S={isValidSecretKey:s,isValidPublicKey:o,randomSecretKey:c},_=Br(c,a);return Object.freeze({getPublicKey:a,getSharedSecret:w,keygen:_,Point:e,utils:S,lengths:i})}function Sa(e,t,n={}){Jr(t),ne(n,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"}),n=Object.assign({},n);const r=n.randomBytes||Xe,i=n.hmac||((f,u)=>Qr(t,f,u)),{Fp:s,Fn:o}=e,{ORDER:c,BITS:a}=o,{keygen:h,getPublicKey:w,getSharedSecret:S,utils:_,lengths:B}=Ea(e,n),d={prehash:!0,lowS:typeof n.lowS=="boolean"?n.lowS:!0,format:"compact",extraEntropy:!1},D=c*Zr<s.ORDER;function A(f){const u=c>>Ot;return f>u}function y(f,u){if(!o.isValidNot0(u))throw new Error(`invalid signature ${f}: out of range 1..Point.Fn.ORDER`);return u}function m(){if(D)throw new Error('"recovered" sig type is not supported for cofactor >2 curves')}function E(f,u){Ye(u);const g=B.signature,x=u==="compact"?g:u==="recovered"?g+1:void 0;return q(f,x)}class R{r;s;recovery;constructor(u,g,x){if(this.r=y("r",u),this.s=y("s",g),x!=null){if(m(),![0,1,2,3].includes(x))throw new Error("invalid recovery id");this.recovery=x}Object.freeze(this)}static fromBytes(u,g=d.format){E(u,g);let x;if(g==="der"){const{r:L,s:C}=At.toSig(q(u));return new R(L,C)}g==="recovered"&&(x=u[0],g="compact",u=u.subarray(1));const I=B.signature/2,K=u.subarray(0,I),v=u.subarray(I,I*2);return new R(o.fromBytes(K),o.fromBytes(v),x)}static fromHex(u,g){return this.fromBytes(Yt(u),g)}assertRecovery(){const{recovery:u}=this;if(u==null)throw new Error("invalid recovery id: must be present");return u}addRecoveryBit(u){return new R(this.r,this.s,u)}recoverPublicKey(u){const{r:g,s:x}=this,I=this.assertRecovery(),K=I===2||I===3?g+c:g;if(!s.isValid(K))throw new Error("invalid recovery id: sig.r+curve.n != R.x");const v=s.toBytes(K),L=e.fromBytes(yt(jr((I&1)===0),v)),C=o.inv(K),j=T(q(u,void 0,"msgHash")),z=o.create(-j*C),P=o.create(x*C),F=e.BASE.multiplyUnsafe(z).add(L.multiplyUnsafe(P));if(F.is0())throw new Error("invalid recovery: point at infinify");return F.assertValidity(),F}hasHighS(){return A(this.s)}toBytes(u=d.format){if(Ye(u),u==="der")return Yt(At.hexFromSig(this));const{r:g,s:x}=this,I=o.toBytes(g),K=o.toBytes(x);return u==="recovered"?(m(),yt(Uint8Array.of(this.assertRecovery()),I,K)):yt(I,K)}toHex(u){return Jt(this.toBytes(u))}}const O=n.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const g=Be(u),x=u.length*8-a;return x>0?g>>BigInt(x):g},T=n.bits2int_modN||function(u){return o.create(O(u))},k=nn(a);function p(f){return Ze("num < 2^"+a,f,bt,k),o.toBytes(f)}function b(f,u){return q(f,void 0,"message"),u?q(t(f),void 0,"prehashed message"):f}function N(f,u,g){const{lowS:x,prehash:I,extraEntropy:K}=ke(g,d);f=b(f,I);const v=T(f),L=o.fromBytes(u);if(!o.isValidNot0(L))throw new Error("invalid private key");const C=[p(L),p(v)];if(K!=null&&K!==!1){const F=K===!0?r(B.secretKey):K;C.push(q(F,void 0,"extraEntropy"))}const j=yt(...C),z=v;function P(F){const tt=O(F);if(!o.isValidNot0(tt))return;const ht=o.inv(tt),Y=e.BASE.multiply(tt).toAffine(),rt=o.create(Y.x);if(rt===bt)return;const re=o.create(ht*o.create(z+rt*L));if(re===bt)return;let bn=(Y.x===rt?0:2)|Number(Y.y&Ot),gn=re;return x&&A(re)&&(gn=o.neg(re),bn^=1),new R(rt,gn,D?void 0:bn)}return{seed:j,k2sig:P}}function M(f,u,g={}){const{seed:x,k2sig:I}=N(f,u,g);return Zs(t.outputLen,o.BYTES,i)(x,I).toBytes(g.format)}function U(f,u,g,x={}){const{lowS:I,prehash:K,format:v}=ke(x,d);if(g=q(g,void 0,"publicKey"),u=b(u,K),!Ge(f)){const L=f instanceof R?", use sig.toBytes()":"";throw new Error("verify expects Uint8Array signature"+L)}E(f,v);try{const L=R.fromBytes(f,v),C=e.fromBytes(g);if(I&&L.hasHighS())return!1;const{r:j,s:z}=L,P=T(u),F=o.inv(z),tt=o.create(P*F),ht=o.create(j*F),Y=e.BASE.multiplyUnsafe(tt).add(C.multiplyUnsafe(ht));return Y.is0()?!1:o.create(Y.x)===j}catch{return!1}}function l(f,u,g={}){const{prehash:x}=ke(g,d);return u=b(u,x),R.fromBytes(f,"recovered").recoverPublicKey(u).toBytes()}return Object.freeze({keygen:h,getPublicKey:w,getSharedSecret:S,utils:_,lengths:B,Point:e,sign:M,verify:U,recoverPublicKey:l,Signature:R,hash:t})}const dn={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Aa={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},$n=BigInt(2);function xa(e){const t=dn.p,n=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),c=BigInt(44),a=BigInt(88),h=e*e*e%t,w=h*h*e%t,S=H(w,n,t)*w%t,_=H(S,n,t)*w%t,B=H(_,$n,t)*h%t,d=H(B,i,t)*B%t,D=H(d,s,t)*d%t,A=H(D,c,t)*D%t,y=H(A,a,t)*A%t,m=H(y,c,t)*D%t,E=H(m,n,t)*w%t,R=H(E,o,t)*d%t,O=H(R,r,t)*h%t,T=H(O,$n,t);if(!He.eql(He.sqr(T),e))throw new Error("Cannot find square root");return T}const He=Ie(dn.p,{sqrt:xa}),va=ma(dn,{Fp:He,endo:Aa}),pt=Sa(va,Se),Ba=33,Ia=32;function _a(e,t,n){const r=Xn.digest(t instanceof Uint8Array?t:t.subarray());if(_e(r))return r.then(({digest:i})=>(n?.signal?.throwIfAborted(),pt.sign(i,e,{prehash:!1,format:"der"}))).catch(i=>{throw i.name==="AbortError"?i:new On(String(i))});try{return pt.sign(r.digest,e,{prehash:!1,format:"der"})}catch(i){throw new On(String(i))}}function Ka(e,t,n,r){const i=Xn.digest(n instanceof Uint8Array?n:n.subarray());if(_e(i))return i.then(({digest:s})=>(r?.signal?.throwIfAborted(),pt.verify(t,s,e,{prehash:!1,format:"der"}))).catch(s=>{throw s.name==="AbortError"?s:new Tn(String(s))});try{return r?.signal?.throwIfAborted(),pt.verify(t,i.digest,e,{prehash:!1,format:"der"})}catch(s){throw new Tn(String(s))}}class Yr{type="secp256k1";raw;_key;constructor(t){this._key=La(t),this.raw=Ua(this._key)}toMultihash(){return Je.digest(Re(this))}toCID(){return X.createV1(114,this.toMultihash())}toString(){return ft.encode(this.toMultihash().bytes).substring(1)}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}verify(t,n,r){return Ka(this._key,n,t,r)}}class Hr{type="secp256k1";raw;publicKey;constructor(t,n){this.raw=Da(t),this.publicKey=new Yr(n??Ca(t))}equals(t){return t==null||!(t.raw instanceof Uint8Array)?!1:wt(this.raw,t.raw)}sign(t,n){return _a(this.raw,t,n)}}function Xr(e){return new Hr(e)}function yn(e){return new Yr(e)}async function Ra(){const e=Na();return new Hr(e)}function Ua(e){return pt.Point.fromBytes(e).toBytes()}function Da(e){try{return pt.getPublicKey(e,!0),e}catch(t){throw new Vn(String(t))}}function La(e){try{return pt.Point.fromBytes(e),e}catch(t){throw new qn(String(t))}}function Ca(e){try{return pt.getPublicKey(e,!0)}catch(t){throw new Vn(String(t))}}function Na(){return pt.utils.randomSecretKey()}const Ke={"P-256":32,"P-384":48,"P-521":66},Oa=Object.keys(Ke),wn=Oa.join(" / ");async function Ta(e){if(e!=="P-256"&&e!=="P-384"&&e!=="P-521")throw new V(`Unknown curve: ${e}. Must be ${wn}`);const t=await J.get().subtle.generateKey({name:"ECDH",namedCurve:e},!0,["deriveBits"]),n=async(s,o)=>{let c;o!=null?c=await J.get().subtle.importKey("jwk",Ma(e,o),{name:"ECDH",namedCurve:e},!1,["deriveBits"]):c=t.privateKey;const a=await J.get().subtle.importKey("jwk",Gr(e,s),{name:"ECDH",namedCurve:e},!1,[]),h=await J.get().subtle.deriveBits({name:"ECDH",public:a},c,Ke[e]*8);return new Uint8Array(h,0,h.byteLength)},r=await J.get().subtle.exportKey("jwk",t.publicKey);return{key:ka(r),genSharedKey:n}}function ka(e){if(e.crv==null||e.x==null||e.y==null)throw new V("JWK was missing components");if(e.crv!=="P-256"&&e.crv!=="P-384"&&e.crv!=="P-521")throw new V(`Unknown curve: ${e.crv}. Must be ${wn}`);const t=Ke[e.crv];return Tt([Uint8Array.from([4]),kn(e.x,t),kn(e.y,t)],1+t*2)}function Gr(e,t){if(e!=="P-256"&&e!=="P-384"&&e!=="P-521")throw new V(`Unknown curve: ${e}. Must be ${wn}`);const n=Ke[e];if(!wt(t.subarray(0,1),Uint8Array.from([4])))throw new V("Cannot unmarshal public key - invalid key format");return{kty:"EC",crv:e,x:$(t.subarray(1,n+1),"base64url"),y:$(t.subarray(1+n),"base64url"),ext:!0}}const Ma=(e,t)=>({...Gr(e,t.public),d:$(t.private,"base64url")}),Pa={SHA1:20,SHA256:32,SHA512:64},$a={SHA1:"SHA-1",SHA256:"SHA-256",SHA512:"SHA-512"},qa=async(e,t)=>{const n=await J.get().subtle.sign({name:"HMAC"},e,t);return new Uint8Array(n,0,n.byteLength)};async function Va(e,t){const n=$a[e],r=await J.get().subtle.importKey("raw",t,{name:"HMAC",hash:{name:n}},!1,["sign"]);return{async digest(i){return qa(r,i)},length:Pa[e]}}const za={"AES-128":{ivSize:16,keySize:16},"AES-256":{ivSize:16,keySize:32},Blowfish:{ivSize:8,keySize:32}};async function Za(e,t,n){if(e!=="AES-128"&&e!=="AES-256"&&e!=="Blowfish")throw new V("Cipher type was missing or unsupported");if(t!=="SHA1"&&t!=="SHA256"&&t!=="SHA512")throw new V("Hash type was missing or unsupported");if(n==null||!(n instanceof Uint8Array))throw new V("Secret was missing or an incorrect type");const r=za[e],i=r.keySize,s=r.ivSize,o=20,c=W("key expansion"),a=2*(s+i+o),h=await Va(t,n);let w=await h.digest(c);const S=[];let _=0;for(;_<a;){const m=await h.digest(Tt([w,c]));let E=m.length;_+E>a&&(E=a-_),S.push(m),_+=E,w=await h.digest(w)}const B=a/2,d=Tt(S),D=d.subarray(0,B),A=d.subarray(B,a),y=m=>({iv:m.subarray(0,s),cipherKey:m.subarray(s,s+i),macKey:m.subarray(s+i)});return{k1:y(D),k2:y(A)}}async function ja(e,t){if(e==="Ed25519")return _o();if(e==="secp256k1")return Ra();if(e==="RSA")return ca(Qa(t));if(e==="ECDSA")return qs(tc(t));throw new Qt}async function Fa(e,t){if(e!=="Ed25519")throw new Qt("Seed key derivation only supported for Ed25519 keys");return Ko(t)}function Ya(e,t){const{Type:n,Data:r}=vt.decode(e),i=r??new Uint8Array;switch(n){case Z.RSA:return aa(i,t);case Z.Ed25519:return on(i);case Z.secp256k1:return yn(i);case Z.ECDSA:return sr(i);default:throw new Qt}}function Ha(e){if(e.byteLength===Gt)return on(e);if(e.byteLength===Ba)return yn(e);const t=Bt(e),n=t[1]?.[0];if(n===Jn||n===Qn||n===tr)return or(t);if(t[0]?.[0]===fa)return Vr(t,e);throw new V("Could not extract public key from raw bytes")}function Xa(e){const{Type:t,Data:n}=vt.decode(e.digest),r=n??new Uint8Array;switch(t){case Z.Ed25519:return on(r);case Z.secp256k1:return yn(r);case Z.ECDSA:return sr(r);default:throw new Qt}}function Re(e){return vt.encode({Type:Z[e.type],Data:e.raw})}function Ga(e){const t=Ee.decode(e),n=t.Data??new Uint8Array;switch(t.Type){case Z.RSA:return oa(n);case Z.Ed25519:return Rr(n);case Z.secp256k1:return Xr(n);case Z.ECDSA:return Ms(n);default:throw new Qt}}function Wa(e){if(e.byteLength===dt)return Rr(e);if(e.byteLength===Ia)return Xr(e);const t=Bt(e),n=t[2]?.[0];if(n===Jn||n===Qn||n===tr)return ir(t);if(t.length>8)return qr(t);throw new V("Could not extract private key from raw bytes")}function Ja(e){return Ee.encode({Type:Z[e.type],Data:e.raw})}function Qa(e){return e==null?2048:parseInt(e,10)}function tc(e){if(e==="P-256"||e==null)return"P-256";if(e==="P-384")return"P-384";if(e==="P-521")return"P-521";throw new V("Unsupported curve, should be P-256, P-384 or P-521")}async function ec(e){if(e.type==="RSA")return{privateKey:await crypto.subtle.importKey("jwk",e.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",e.publicKey.jwk,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])};if(e.type==="ECDSA")return{privateKey:await crypto.subtle.importKey("jwk",e.jwk,{name:"ECDSA",namedCurve:e.jwk.crv??"P-256"},!0,["sign"]),publicKey:await crypto.subtle.importKey("jwk",e.publicKey.jwk,{name:"ECDSA",namedCurve:e.publicKey.jwk.crv??"P-256"},!0,["verify"])};throw new V("Only RSA and ECDSA keys are supported")}async function nc(e){if(e.privateKey.algorithm.name==="RSASSA-PKCS1-v1_5"){const t=await crypto.subtle.exportKey("jwk",e.privateKey);return zr(t)}if(e.privateKey.algorithm.name==="ECDSA"){const t=await crypto.subtle.exportKey("jwk",e.privateKey);return new Zt(t)}throw new V("Only RSA and ECDSA keys are supported")}const oc=Object.freeze(Object.defineProperty({__proto__:null,generateEphemeralKeyPair:Ta,generateKeyPair:ja,generateKeyPairFromSeed:Fa,keyStretcher:Za,privateKeyFromCryptoKeyPair:nc,privateKeyFromProtobuf:Ga,privateKeyFromRaw:Wa,privateKeyToCryptoKeyPair:ec,privateKeyToProtobuf:Ja,publicKeyFromMultihash:Xa,publicKeyFromProtobuf:Ya,publicKeyFromRaw:Ha,publicKeyToProtobuf:Re},Symbol.toStringTag,{value:"Module"}));export{X as C,ic as I,Qt as U,sc as a,ft as b,V as c,Vi as d,wt as e,W as f,zt as g,fs as h,Je as i,ta as j,Tr as k,Or as l,Mr as m,Ya as n,Tt as o,Xa as p,ue as q,Re as r,Xn as s,$ as t,oc as u};
